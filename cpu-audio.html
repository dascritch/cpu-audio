<!--

Cpu-Audio, an extension to the hash system to address timecode into audio/video elements
Copyright (C) 2014-2018 Xavier "dascritch" Mouton-Dubosc

Previously TimecodeHash, then OndeMirroir Audio Tag

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

project repository : https://github.com/dascritch/cpu-audio
blog post : http://dascritch.net/post/2014/09/03/Timecodehash-%3A-Lier-vers-un-moment-d-un-sonore

-->

<style>
	/* Global default style, usign var. Integrators may override them */
	:root {
		--cpu-height : 64px;
		--cpu-font-family : Lato, "Open Sans", "Segoe UI", Frutiger, "Frutiger Linotype", "Dejavu Sans", "Helvetica Neue", Arial, sans-serif;
		--cpu-font-size : 15px;
		--cpu-background : #555;
		--cpu-color : #ddd;
		--cpu-playing-background : #444;
		--cpu-playing-color : #fff;
		--cpu-error-background : #a00 ;
		--cpu-error-color : #ff7 ;
		--cpu-popup-background : #aaa;
		--cpu-popup-color : #333;
		--cpu-elapse-width : 185px;
	}

	@media (max-width: 640px) , @element .interface and (max-width: 640px) {
		:root , .interface {
			--cpu-font-size : 13px;
			--cpu-height : 32px;
		}
	}
</style>

<template>
<style>

.interface {
	font-family : var(--cpu-font-family);
	font-size : var(--cpu-font-size);
}

.interface, * {
	line-height : 1.2;
	border : none;
	padding : 0;
	margin : 0;
	transition : none;
	moz-user-select: none;
	ms-user-select: none;
	webkit-user-select: none;
	user-select: none;
}


.principal {
	display : flex;
	overflow : hidden;
	background : var(--cpu-background);
	color : var(--cpu-color);
	height : var(--cpu-height);
}

.act-error {
	background : var(--cpu-error-background);
	color : var(--cpu-error-color);
}

a {
	color : var(--cpu-color);
	border : none;
	text-decoration : none;
}
svg {
	fill : var(--cpu-color);
	width : var(--cpu-height);
	height : var(--cpu-height);
}
a:hover, a:focus {
	color : var(--cpu-background);
	background : var(--cpu-color);
}
a:hover svg , a:focus svg {
	fill : var(--cpu-background);
}

.loading circle {
	fill : #777;
}

.act-play {
	background : var(--cpu-playing-background);
	color : var(--cpu-playing-color);
}

.act-play svg {
	fill : var(--cpu-playing-color);
}

.act-play a {
	color : var(--cpu-playing-color);
}

.act-play a:hover, .act-play a:focus {
	color : var(--cpu-playing-background);
	background : var(--cpu-playing-color);
}
.act-play a:hover svg, .act-play a:focus svg {
	fill : var(--cpu-playing-background);
}

.show-error {
	background : var(--cpu-error-background);
	color : var(--cpu-error-color);
}

.pageerror {
	padding: 0px 4px;
    align-self: center;
}

.control,
.actions,
.back {
	flex : 0 0 var(--cpu-height);
	width : var(--cpu-height);
	max-height : var(--cpu-height);
	height : 100%;
	text-align : center;
	vertical-align : middle;
}

a {
	cursor : pointer;
}

.loading, .play, .pause,
.show-main .pageshare, .show-main .pageerror,
.show-share .pagemain, .show-share .pageerror,
.show-error .pagemain, .show-error .pageshare , .show-error .poster {
	display : none;
}

.act-loading .loading,
.act-play .play,
.act-pause .pause {
	display : block;
}

.show-share .pageshare,
.show-main .pagemain,
.share {
	flex : 1 1 100%;
	display : flex;
	align-items: center;
}

.act-loading .loading circle:nth-child(1) {
	  animation: pulse0 2s infinite;
}

.act-loading .loading circle:nth-child(2) {
	  animation: pulse1 2s infinite;
}

.act-loading .loading circle:nth-child(3) {
	  animation: pulse2 2s infinite;
}

@keyframes pulse0 {
	0%		{opacity : 1;}
	50%		{opacity : 0;}
	100%	{opacity : 1;}
}

@keyframes pulse1 {
	0%		{opacity : 0.75;}
	12%		{opacity : 1;}
	62%		{opacity : 0;}
	100%	{opacity : 0.75;}
}

@keyframes pulse2 {
	0% 		{opacity : 0.5;}
	25% 	{opacity : 1;}
	75%		{opacity : 0;}
	100% 	{opacity : 0.5;}
}

@keyframes pulse3 {
	0% 		{opacity : 0.25;}
	37% 	{opacity : 1;}
	87% 	{opacity : 0;}
	100% 	{opacity : 0.25;}
}

.poster {
	width : var(--cpu-height);
	height : var(--cpu-height);
	object-fit: contain;
}

.loading svg, .play svg, .pause svg, .actions svg {
	vertical-align : middle;
	max-width : 100%;
	max-height : 100%;
}
.loading {
	background : var(--cpu-background) !important;
}
.titleline {
	display : flex;
}
.about, .title {
	flex : 1 1 100%;
	position : relative;
}
.title a {
	display : block;
	text-overflow : ellipsis;
	max-height: 48px;
	overflow: hidden;
}
.canonical.untitled {
	font-style : italic;
}
.elapse {
	flex : 1 0 var(--cpu-elapse-width);
	text-align : right;
}
.time {
	background : black;
	width : 100%;
	height : 10px;
	display : block;
	border-radius : 4px;
	position : relative;
	cursor:none;
}
.loadingline,
.elapsedline {
	background : white;
	height : 10px ;
	display : block ;
	position : absolute;
	left : 0;
	border-radius : 4px;
	pointer-events : none;
}
.elapsedline {
	z-index : 2;
}

.act-loading .loadingline {
	background : grey;
}

.share {
	text-align : center;
}

.share a {
	height : var(--cpu-height);
}

.share a, .share div {
	flex : 1 0;
	color : white;
	text-decoration : none;
	overflow : hidden;
	text-overflow : clip;
}

.share a:hover, .share a:focus, .share div:hover {
	color : var(--cpu-background);
	background : var(--cpu-color);
}

.share svg {
	vertical-align : middle;
	width : 32px;
	height : 32px;
}
.twitter {
	background : #4DB5F4
}
.facebook {
	background : #5974CC
}
.email {
	background : #CC0000
}
.link {
	background : #77F
}

.popup {
	pointer-events : none;
	position: absolute;
	transform: translate(-25px, -19px);
	z-index : 127;
	min-width : 50px;
	font-size : 11px;
	text-align : center;
	padding : 2px;
	border-radius: 4px;
	box-shadow: black 2px 2px;
	background : var(--cpu-popup-background);
	color : var(--cpu-popup-color);
	opacity : 0;
	/* absolute pos, need to repeat it →  https://developer.mozilla.org/en-US/docs/Web/CSS/user-select */
	moz-user-select: none;
	ms-user-select: none;
	webkit-user-select: none;
	user-select: none;
} 
.popup:before {
	pointer-events : none;
	content:"";
	position: absolute;
	z-index : 127;
	left: 20px;
	bottom: -8px;
	width: 0;
	height : 0;
	/* arrow form */
	border-top: 8px solid var(--cpu-popup-background);
	border-left: 4px solid transparent;
	border-right: 4px solid transparent;
} 

.chapters {
	display : flex;
	overflow : scoll;
	background : var(--cpu-background);
	color : var(--cpu-color);
	list-style: none;
	flex-direction: column;	
}
.cue {
	border-top : 1px solid black;
}
.active-cue {
	background : black;
}
.cue.active-cue {
	color : yellow;
}
.cue a {
	display : flex;
	margin : 0px;
	padding : 2px
}
.cue strong {
	flex : 1 1;
	font-weight : normal;
}
.cue span {
	flex : 0 0 var(--cpu-elapse-width);
	text-align : right;
}


.mode-compact {
	width : calc(var(--cpu-elapse-width) + var(--cpu-height) + 32px);
}

.mode-button {
	width : var(--cpu-height);
}

.mode-compact .poster,
.mode-compact .title,
.mode-compact .line,
.mode-compact .actions,
.mode-button .poster,
.mode-button .about,
.mode-button .actions,
.mode-hidden 
 {
	display : none;
}

.mode-compact.show-main .pagemain {
	flex : 0 0 auto;
}

@media (max-width: 640px) , @element .interface and (max-width: 640px) {

	.nosmall {
		display : none;
	}
	.title a {
		max-height : 16px;
	}

	.elapse {
		flex : 1 0 160px;
		max-height : 16px;
	}

	.time,
	.loadingline,
	.elapsedline {
		height : 8px ;
	}
}
@media (max-width: 480px) , @element .interface and (max-width: 480px) {
	.mode-default .notiny {
		display : none;
	}

	.mode-default .elapse {
		flex : 1 0 80px;
	}
}
@media (max-width: 320px) , @element .interface and (max-width: 320px) {
	.mode-default .elapse {
		display : none;
	}
}

@media print {
	.interface {
		display : none;
	}
}

</style>

<div class="interface" tabindex="0">
	<div class="principal">
		<img class="poster nosmall" src="" alt="" />
		<div class="pageerror">
		</div>
		<div class="pagemain">
			<a class="control" tabindex="0">
				<div class="loading" title="Chargement en cours">
					<svg viewBox="0 0 32 32">
						<circle cx="6" cy="22" r="4" />
						<circle cx="16" cy="22" r="4" />
						<circle cx="26" cy="22" r="4" />
					</svg>
				</div>
				<div class="play" title="Lecture">
					<svg viewBox="0 0 32 32">
						<path d="M 6,6 12.667,6 12.667,26 6,26 z" />
						<path d="M 19.333,6 26,6 26,26 19.333,26 z" />
					</svg>
				</div>
				<div class="pause" title="Pause">
					<svg viewBox="0 0 32 32">
						<path d="M 6,6 6,26 26,16 z" />
					</svg>
				</div>
			</a>
			<div class="about">
				<div class="titleline">
					<div class="title"><a href="#" class="canonical" title="Lien vers la fiche du sonore"></a></div>
					<a class="elapse" title="Lien direct à ce moment" tabindex="-1">…</a>
				</div>
				<div class="line">
					<div class="time">
						<div class="loadingline"></div>
						<div class="elapsedline"></div>
						<time class="popup">--:--</time>
					</div>
				</div>
			</div>
			<a class="actions">
				<svg viewBox="0 0 32 32">
					<circle cx="12" cy="10" r="4" /><circle cx="12" cy="22" r="4" /><circle cx="23" cy="16" r="4" /><polygon points="12,8 24,14 24,18 12,12"/><polygon points="12,20 24,14 24,18 12,24"/>
				</svg>
			</a>
		</div>
		<div class="pageshare">
			<div class="share">
				<a href="#" target="social" class="twitter nosmall" title="Partager sur Twitter">
					<svg viewBox="0 0 32 32">
						<path d="M 25.941,9.885 C 25.221,10.205 24.448,10.422 23.637,10.520 24.465,10.020 25.101,9.230 25.401,8.288 24.626,8.750 23.768,9.086 22.854,9.267 22.122,8.483 21.080,7.993 19.926,7.993 c -2.215,0 -4.011,1.806 -4.011,4.034 0,0.316 0.035,0.623 0.103,0.919 -3.333,-0.168 -6.288,-1.774 -8.267,-4.215 -0.345,0.596 -0.542,1.289 -0.542,2.028 0,1.399 0.708,2.634 1.784,3.358 -0.657,-0.020 -1.276,-0.202 -1.816,-0.504 -3.98e-4,0.016 -3.98e-4,0.033 -3.98e-4,0.050 0,1.954 1.382,3.585 3.217,3.955 -0.336,0.092 -0.690,0.141 -1.056,0.141 -0.258,0 -0.509,-0.025 -0.754,-0.072 0.510,1.602 1.991,2.769 3.746,2.801 -1.372,1.082 -3.102,1.726 -4.981,1.726 -0.323,0 -0.642,-0.019 -0.956,-0.056 1.775,1.144 3.883,1.812 6.148,1.812 7.377,0 11.411,-6.147 11.411,-11.478 0,-0.174 -0.004,-0.348 -0.011,-0.522 0.783,-0.569 1.463,-1.279 2.001,-2.088 z" />
					</svg>
					<span>Partager sur Twitter</span>
				</a>
				<a href="#" target="social" class="facebook nosmall" title="Partager sur Facebook">
					<svg viewBox="0 0 32 32">
						<path d="m 21.117,16.002 -3.728,0 0,10.027 -4.297,0 0,-10.027 -2.070,0 0,-3.280 2.070,0 0,-2.130 c 0,-2.894 1.248,-4.616 4.652,-4.616 l 3.922,0 0,3.549 -3.203,0 c -0.950,-0.001 -1.068,0.495 -1.068,1.421 l -0.005,1.775 4.297,0 -0.568,3.280 0,2.34e-4 z" />
					</svg>
					<span>Partager sur Facebook</span>
				</a>
				<a href="#" target="social" class="email" title="Partager par e-mail">
					<svg viewBox="0 0 32 32">
						<path d="m 8.030,8.998 15.920,0 c 0.284,0 0.559,0.053 0.812,0.155 l -8.773,9.025 -8.773,-9.026 c 0.253,-0.101 0.528,-0.155 0.812,-0.155 z m -1.990,12.284 0,-10.529 c 0,-0.036 0.002,-0.073 0.004,-0.109 l 5.835,6.003 -5.771,5.089 c -0.045,-0.146 -0.068,-0.298 -0.069,-0.453 z m 17.910,1.754 -15.920,0 c -0.175,0 -0.348,-0.020 -0.514,-0.060 l 5.662,-4.993 2.811,2.892 2.811,-2.892 5.662,4.993 c -0.165,0.039 -0.338,0.060 -0.514,0.060 z m 1.990,-1.754 c 0,0.155 -0.023,0.307 -0.068,0.453 l -5.771,-5.089 5.835,-6.003 c 0.002,0.036 0.004,0.073 0.004,0.109 z" />
					</svg>
					<span>Partager par e-mail</span>
				</a>
				<a href="#" target="social" class="link" title="Télécharger">
					<svg viewBox="0 0 32 32">
						<path d="M 6,6 26,6 16,26 z" /><rect x="6" y="22" width="20" height="4" />
					</svg>
					<span>Télécharger</span></a>
				<a class="back" title="Annuler">Annuler</a>
			</div>
		</div>
	</div>
	<ul class="chapters">
	</ul>
</div>
</template>

<script>
(function(){

'use strict';

const thisDoc = (document._currentScript || document.currentScript).ownerDocument;

let template, shadow_element;

const CpuAudioTagName = 'CPU-AUDIO';
const CpuControllerTagName = 'CPU-CONTROLLER';
const selector_interface = '.interface';

const cpu_i18n = {
	'untitled' : '(sans titre)',
	'cover' : 'pochette',
	'more' : 'Partager',
	'twitter' : 'Partager sur Twitter',
	'facebook' : 'Partager sur Facebook',
	'e-mail' : 'Partager par e-mail',
	'download' : 'Télécharger',
	'back' : 'Annuler',

	'media_err_aborted' : 'Vous avez annulé la lecture.',
	'media_err_network' : 'Une erreur réseau a causé l\'interruption du téléchargement.',
	'media_err_decode' : 'La lecture du sonore a été annulée suite à des problèmes de corruption ou de fonctionnalités non supportés par votre navigateur.',
	'media_err_src_not_supported' : 'Le sonore n\'a pu être chargé, soit à cause de sourcis sur le serveur, le réseau ou parce que le format n\'est pas supporté.',
	'media_err_unknow' : 'Erreur due à une raison inconnue'
};

function onDebug(callback_fx) {
	// this is needed for testing, as we now run in async tests
	if (typeof callback_fx === 'function') {
		callback_fx();
	}
}

function querySelector_apply(selector, callback, subtree) {
	subtree = subtree === undefined ? document : subtree;
	Array.from(subtree.querySelectorAll(selector)).forEach(callback);
}

function is_decent_browser_for_webcomponents() {
	return window.customElements !== undefined;
}

const convert = {
	_units : {
		'd' : 86400,
		'h' : 3600,
		'm' : 60,
		's' : 1
	},

	TimeInSeconds : function(givenTime) {
		let seconds = 0;
		if (/^\d+$/.test(givenTime)) {
			seconds = Number(givenTime);
		} else {
			seconds = (givenTime.indexOf(':') === -1) ? this.SubunitTimeInSeconds(givenTime) : this.ColonTimeInSeconds(givenTime) ;
		}
		return seconds;
	},
	SubunitTimeInSeconds : function(givenTime) {
		let seconds = 0;
		for(let key in convert._units) {
			if ( (convert._units.hasOwnProperty(key)) && (givenTime.indexOf(key) !== -1) ) {
				let atoms = givenTime.split(key);
				seconds += Number(atoms[0].replace(/\D*/g,'' )) * convert._units[key];
				givenTime = atoms[1];
			}
		}
		return seconds;
	},
	ColonTimeInSeconds : function(givenTime) {
		let seconds = 0;
		let atoms = givenTime.split(':');
		let convert = [1, 60, 3600, 86400];
		for (let pos = 0 ; pos < atoms.length ; pos++) {
			seconds += Number(atoms[pos]) * convert[((atoms.length-1) - pos)];
		}
		return seconds;
	},
	SecondsInTime : function(givenSeconds) {
		let converted = '';
		let inned = false;
		for(let key in convert._units) {
			if (convert._units.hasOwnProperty(key)) {
				let multiply = convert._units[key];
				if ((givenSeconds >= multiply) || (inned)) {
					inned = true;
					let digits = Math.floor(givenSeconds / multiply);
					converted += digits + key;
					givenSeconds -= digits * multiply;
				}
			}
		}
		return converted === '' ? '0s' : converted;
	},
	SecondsInColonTime : function(givenSeconds) {
		let converted = '';
		let inned = false;
		for(let key in convert._units) {
			if (convert._units.hasOwnProperty(key)) {
				let multiply = convert._units[key];
				if ((givenSeconds >= multiply) || (inned)) {
					inned = true;
					let digits = Math.floor(givenSeconds / multiply);
					converted += (converted === '' ? '' : ':');
					converted += ( ((digits<10) && (converted !== '')) ? '0' : '') + digits ;
					givenSeconds -= digits * multiply;
				}
			}
		}
		if (converted.length === 1) {
			return '0:0' + converted;
		}
		if (converted.length === 2) {
			return '0:' + converted;
		} 
		
		return converted === '' ? '0:00' : converted;
	},
}

const trigger = {

	hashOrder : function(hashcode, callback_fx){
		let at_start = true;
		if (typeof hashcode !== 'string') {
			at_start = 'at_start' in hashcode;
			hashcode = location.hash.substr(1);
		}
		let hash = '';
		let timecode = '';
		let segments = hashcode.split('&');
		let autoplay = false;

		for (let _id in segments) {
			let parameter = segments[_id];
			if ((parameter.indexOf('=') === -1) && (hash === '')) {
				// should reference to the ID of the element
				hash = parameter;
			} else {
				// should be a key=value parameter
				let atoms = parameter.split('=');
				let p_key = atoms[0];
				let p_value = atoms[1];
				switch (p_key) {
					case 't':
						// is a time index
						timecode = p_value;
						// we make autoplay at requested timecode, simplier of the user
						autoplay = true;
						break;
					case 'autoplay':
						// is a card from a social network, run now
						autoplay =  p_value === '1';
						break;
					case 'auto_play':
						// is a card from a social network, run now
						autoplay = p_value === 'true';
						break;
				}

			}
		}

		if ((timecode === '') || ((at_start) && (!autoplay))) {
			// this is a normal anchor call. Go back to normal behaviour
			onDebug(callback_fx);
			return false;
		}

		CPU_Audio.jumpIdAt(hash, timecode, callback_fx);
		// scroll to the audio element. Should be reworked
		// window.location.hash = `#${hash}`;
		return true;
	},
	hover : function(event) {
		let container = CPU_Audio.find_container(event.target);

		let target_rect = event.target.getClientRects()[0];
		let relLeft = target_rect.left;
		let ratio = event.offsetX / event.target.clientWidth;
		let seeked_time = ratio * container.audiotag.duration;

		container.show_throbber_at(seeked_time);
	},
	out : function(event) {
		let container = CPU_Audio.find_container(event.target);
		container.hide_throbber();
	},

	throbble : function(event) {
		let at = 0;
		let container = CPU_Audio.find_container(event.target);
		let audiotag = container.audiotag;
		if (event.at !== undefined) {
			at = event.at;
		} else {
			// normal usage
			let ratio = event.offsetX  / event.target.clientWidth;
			at = ratio * audiotag.duration;
		}
		CPU_Audio.seekElementAt(audiotag, at);
		trigger.play(event);
	},
	pause : function(event, audiotag) {
		if (audiotag === undefined) {
			let target = event.target;
			audiotag = (target.tagName === 'AUDIO') ? target : CPU_Audio.find_container(target).audiotag;
		}
		audiotag.pause();
		CPU_Audio.current_audiotag_playing = null;
		window.localStorage.removeItem(audiotag.currentSrc);
	},
	play_once : function(event) {
		let audiotag = event.target;
		
		if ( (CPU_Audio.only_play_one_audiotag) && (CPU_Audio.current_audiotag_playing) && (!audiotag.isEqualNode(CPU_Audio.current_audiotag_playing)) ) {
			trigger.pause(undefined, CPU_Audio.current_audiotag_playing);
		}
		CPU_Audio.current_audiotag_playing = audiotag;
	},
	play : function(event, audiotag) {
		if (audiotag === undefined) {
			audiotag = CPU_Audio.find_container(event.target).audiotag;
		}
		if (CPU_Audio.global_controller) {
			CPU_Audio.global_controller.attach_audiotag_to_controller(audiotag);
			CPU_Audio.global_controller.audiotag = audiotag;
			CPU_Audio.global_controller.show_main();
		}
		audiotag.play();
	},
	key : function(event) {
		let container = CPU_Audio.find_container(event.target);

		function seek_relative(seconds) {
			event.at = container.audiotag.currentTime + seconds;
			container.show_throbber_at(event.at);
			trigger.throbble(event);
			container.hide_throbber_later();
		}

		switch (event.keyCode) {
			// can't use enter : standard usage
			case 27 : // esc
				CPU_Audio.seekElementAt(container.audiotag, 0);
				trigger.pause(undefined,container.audiotag);
				break;
			case 32 : // space
				container.audiotag.paused ?
					trigger.play(undefined,container.audiotag) :
					trigger.pause(undefined,container.audiotag);
				break;
			case 35 : // end
				CPU_Audio.seekElementAt(container.audiotag, container.audiotag.duration);
				break;
			case 36 : // home
				CPU_Audio.seekElementAt(container.audiotag, 0);
				break;
			case 37 : // ←
				seek_relative(- CPU_Audio.keymove);
				break;
			case 39 : // →
				seek_relative(+ CPU_Audio.keymove);
				break;
			default:
				return ;
		}
		event.preventDefault();
	},
	keydownplay : function(event) {
		if (event.keyCode !== 13 ) {
			return;
		} 
		let container = CPU_Audio.find_container(event.target);

		container.audiotag.paused ?
			trigger.play(undefined,container.audiotag) :
			trigger.pause(undefined,container.audiotag);
		
		event.preventDefault();
	},

	cuechange : function(event, chapters_element) {
		if (chapters_element === undefined) {
			return;
		}
		let classname = 'active-cue';
		let previous = chapters_element.querySelector(`.${classname}`);
		if (previous !== null) {
			previous.classList.remove(classname);
		}
		if (event.target.activeCues.length === 0) {
			// too early, we need to keep this case from Chrome
			return;
		}

		let cue_id = event.target.activeCues[0].id;
		chapters_element.querySelector(`#${cue_id}`).classList.add(classname);
	},

	update : function(event) {
		let audiotag = event.target;
		audiotag.CPU_update();
		if (!audiotag.paused) {
			window.localStorage.setItem(audiotag.currentSrc, String(audiotag.currentTime));
		}
	},
}

function absolutize_url(url) {
	let test_element = document.createElement('a');
	test_element.href = url;
	return test_element.href;
}

function not_screen_context() {
	return !window.matchMedia("screen").matches;
}

function prevent_link_on_same_page(event) {
	if (absolutize_url(window.location.href) !== absolutize_url(event.target.href)) {
		return ;
	}
	event.preventDefault();
}

function element_prevent_link_on_same_page(element) {
	element.addEventListener('click', prevent_link_on_same_page);
}

function _isEvent(event) {
	// is this event really triggered via a native event ?
	return event.preventDefault !== undefined;
}

const CPU_Audio = {
	// global object for global controller
	keymove : 5,
	only_play_one_audiotag : true,
	current_audiotag_playing : null,
	global_controller : null,
	dynamicallyAllocatedIdPrefix : 'CPU-Audio-tag-',
	count_element : 0,
	convert : convert, // Needed for tests
	trigger : trigger, // Needed for tests

	// NOTE : we will need to refresh this when the <head> of the host page changes
	default_dataset : {
		'title' : function () { 
				for(let domain of ['og', 'twitter']){
					let header_element = window.document.querySelector(`meta[property="${domain}:title"]`);
					if (header_element !== null) {
						return header_element.content;
					}
				}
				let title = window.document.title;
				return title === '' ? null : title;
			}(), 
		'poster' : function () {
				for(let attr of ['property="og:image"', 'name="twitter:image:src"']){
					let header_element = window.document.querySelector(`meta[${attr}]`);
					if (header_element !== null) {
						return header_element.content;
					}
				}
				return null;
			}(),
		'canonical' : function () {
				let header_element = window.document.querySelector('link[rel="canonical"]');
				if (header_element !== null) {
					return header_element.href;
				}
				return window.location.href;
			}(),
		'twitter' : function () {
				let header_element = window.document.querySelector('meta[name="twitter:creator"]');
				if ((header_element !== null) && (header_element.content.length>1)) {
					return header_element.content;
				}
				return null;
			}()
	},

	recall_stored_play : function(event) {
		if (CPU_Audio.current_audiotag_playing !== null) {
			return;
		} 
		let audiotag = event.target;
		let lasttimecode = Number(window.localStorage.getItem(audiotag.currentSrc));
		// TODO and no hashed time
		if (lasttimecode > 0) {
			CPU_Audio.seekElementAt(audiotag, lasttimecode);
			trigger.play(undefined, audiotag);
		}
	},
	recall_audiotag : function(audiotag) {
		audiotag.addEventListener('loadedmetadata', CPU_Audio.recall_stored_play);
		audiotag.addEventListener('play', trigger.play_once);
		// audiotag.addEventListener('progress', trigger.play_once);
		// those ↓ for PHRACKING SAFARI
		audiotag.addEventListener('ready', CPU_Audio.recall_stored_play);
		audiotag.addEventListener('canplay', CPU_Audio.recall_stored_play);

		// see https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events for list of events
		[
			'ready', 'load', 'loadeddata', 'canplay', 'abort', 
			'error', 'stalled', 'suspend', 'emptied',
			'play', 'playing', 'pause', 'ended',
			'durationchange',  'loadedmetadata', 'progress', 'timeupdate', 'waiting'
		].forEach( function(on){ 
			audiotag.addEventListener(on, trigger.update); 
		});

		if (!is_decent_browser_for_webcomponents()) {
			// in case we are in legacy mode
			[
				'pause', 'ended'
			].forEach( function(on){ 
				audiotag.addEventListener(on, trigger.pause);
			});
		}

		

		// ask ASAP metadata about media
		// we have to set in HTML code preload="none" due to a very laggy behaviour in HTTP2
		// https://stackoverflow.com/questions/14479413/chrome-ignoring-audio-preload-metadata
		if (audiotag.preload === '') {
			audiotag.preload = 'metadata';
		}
		audiotag.load();
	},

	connect_audiotag : function(audiotag) {

		audiotag.addEventListener('loadedmetadata', CPU_Audio.find_container(audiotag).build_chapters);

		CPU_Audio.recall_audiotag(audiotag);

		// hide native controls
		audiotag.hidden = true;
		// PHRACK SAFARI
		audiotag.removeAttribute('controls');
	},

	jumpIdAt : function(hash, timecode, callback_fx) {

		function do_needle_move(event) {
			let audiotag = event.target;

			if (_isEvent(event)) {
				audiotag.removeEventListener('loadedmetadata', do_needle_move, true);
			}

			let secs = convert.TimeInSeconds(timecode);
			CPU_Audio.seekElementAt(audiotag, secs);

			if (audiotag.readyState >= audiotag.HAVE_FUTURE_DATA)  {
				do_element_play({ target : audiotag });
			} else {
				audiotag.addEventListener('canplay', do_element_play, true);
			}
			trigger.update({target : audiotag});
		}

		function do_element_play(event) {
			let tag = event.target;
			trigger.play(undefined, tag)
			if (_isEvent(event)) {
				tag.removeEventListener('canplay', do_element_play, true);
			}
			onDebug(callback_fx);
		}

		let selector_fallback = 'cpu-audio audio'; // should be 'audio[controls]' but PHRACK APPLE !
		let audiotag = (hash !== '') ? document.getElementById(hash) : document.querySelector(selector_fallback);

		if ((audiotag === undefined) || (audiotag === null) || (audiotag.currentTime === undefined)) {
			console.warn('jumpIdAt audiotag ', audiotag)
			return false;
		}

		if (audiotag.readyState < audiotag.HAVE_CURRENT_DATA ) {
			audiotag.addEventListener('loadedmetadata', do_needle_move , true);
			audiotag.load();
		} else {
			do_needle_move({target : audiotag});
		}
		trigger.update({target : audiotag});
	},

	find_interface : function(child) {
		return child.closest(selector_interface);
	},
	find_container : function(child) {

		if ((child.tagName === CpuAudioTagName) 
			|| ( child.tagName === CpuControllerTagName)) {
			return child.CPU
		}
		if (child.tagName === 'AUDIO') {
			return child.parentNode.CPU
		}
		return this.find_interface(child).parentNode.host.CPU;
	},
	seekElementAt : function (audiotag, seconds) {

		if (isNaN(seconds)) {
			// may happens, if the audio track is not loaded/loadable
			return;
		}

		if (audiotag.fastSeek !== undefined) {
			audiotag.fastSeek(seconds);
			// Firefox doesn't see fastSeek
		} else {
			try {
				// but can set currentTime
				audiotag.currentTime = seconds;
			} catch(e) {
				// exept sometimes, so you must use standard media fragment
				audiotag.src = `${audiotag.currentSrc.split('#')[0]}#t=${seconds}`;
			}
		}

		let controller = audiotag.CPU_controller();
		if ((controller !== null) && (controller.update_loading)) {
			// it may be still constructing it
			controller.update_loading(seconds);
		}
	}

}

// Extension on media element

HTMLAudioElement.prototype.CPU_controller = function() {
	return this.closest(CpuAudioTagName);
}

HTMLAudioElement.prototype.CPU_update = function() {
	let controller = this.CPU_controller();
	if (controller) {
		let api = controller.CPU;
		if ((api) && (api.update)) {
			// i don't like try catch
			api.update();
		}
	}
	if (CPU_Audio.global_controller) {
		CPU_Audio.global_controller.update();
	}
}

var CPU_element_api = class {
	constructor(element, container_interface) {
		// I hate this style. I rather prefer the object notation
		this.element = element;
		this.elements = {};
		this.audiotag = element._audiotag;
		this.container = container_interface;
	}

	update_act_container(act) {
		this.container.classList.remove(
			'act-loading',
			'act-pause',
			'act-play'
			);
		this.container.classList.add(`act-${act}`);
	}
	update_playbutton() {
		if (this.audiotag.readyState < this.audiotag.HAVE_CURRENT_DATA ) {
			this.update_act_container('loading');
			return;
		}

		this.update_act_container(this.audiotag.paused ? 'pause' : 'play');
	}
	update_line(type, seconds) {
		// type = 'elapsed', 'loading'
		let duration = this.audiotag.duration;
		this.elements[`${type}line`].style.width = duration === 0
												? 0
												: `${100*seconds / duration}%`;
	}
	update_buffered() {
		let end = 0;
		let buffered  = this.audiotag.buffered ;
		let segment;
		for (segment=0 ; segment++; segment < buffered.length) {
			end = buffered.end(segment)
		}
		this.update_line('elapsed', end);
	}
	update_time(event) {
		let timecode = convert.SecondsInTime(this.audiotag.currentTime);
		let link_to = absolutize_url(this.audiotag.dataset.canonical)+'#';
		link_to += this.audiotag.id ? (this.audiotag.id+'&') : '';
		link_to += 't='+timecode;

		let elapse_element = this.elements['elapse'];
		elapse_element.href = link_to;

		let total_duration = '…';
		if (!isNaN(Math.round(this.audiotag.duration))){
			total_duration = convert.SecondsInColonTime(Math.round(this.audiotag.duration));
		} 
		 
		elapse_element.innerHTML = `${convert.SecondsInColonTime(this.audiotag.currentTime)}
									<span class="notiny"> / ${total_duration}</span>`;
		this.update_line('loading', this.audiotag.currentTime);
		this.update_buffered();
	}
	update_loading(seconds) {
		this.update_line('loading', seconds);
		this.update_act_container('loading');
	}
	update_error() {
		// NOTE : this is not working, even on non supported media type
		// Chrome logs an error « Uncaught (in promise) DOMException: Failed to load because no supported source was found. »
		// but don't update message
		if (this.audiotag.error !== null) {
			let error_message;
			let pageerror = this.elements['pageerror'];
			this.show_interface('error');
			switch (this.audiotag.error.code) {
				case this.audiotag.error.MEDIA_ERR_ABORTED:
					error_message = cpu_i18n.media_err_aborted;
					break;
				case this.audiotag.error.MEDIA_ERR_NETWORK:
					error_message = cpu_i18n.media_err_network;
					break;
				case this.audiotag.error.MEDIA_ERR_DECODE:
					error_message = cpu_i18n.media_err_decode;
					break;
				case this.audiotag.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
					error_message = cpu_i18n.media_err_src_not_supported;
					break;
				default:
					error_message = cpu_i18n.media_err_unknow;
					break;
			}
			pageerror.innerText = error_message;
			return true;
		}
		return false;
	}
	update() {
		if (!this.update_error()) {
			this.update_playbutton();
			this.update_time();
		}
	}

	show_throbber_at(seeked_time) {
		if (this.audiotag.duration < 1) {
			// do not try to show if no metadata
			return;
		}
		let phylactere = this.elements['popup'];
		let elapse_element = this.elements['line'];

		phylactere.style.opacity = 1;
		phylactere.style.left = (100 * seeked_time / this.audiotag.duration) +'%';
		phylactere.innerHTML = convert.SecondsInColonTime(seeked_time);
	}
	hide_throbber(that) {
		that = that === undefined ? this : that;
		let phylactere = that.elements['popup'];
		phylactere.style.opacity = 0;
	}
	hide_throbber_later() {
		let phylactere = this.elements['popup'];
		if (phylactere._hider) {
			window.clearTimeout(phylactere._hider);
		}
		phylactere._hider = window.setTimeout(this.hide_throbber, 1000, this);
	}

	fetch_audiotag_dataset() {
		let dataset = {} 
		for (let key in CPU_Audio.default_dataset) {
			let value = null;
			if (key in this.audiotag.dataset) {
				value = this.audiotag.dataset[key];
			} else {
				if (CPU_Audio.default_dataset[key] !== null) {
					value = CPU_Audio.default_dataset[key];
				}
			}
			dataset[key] = value === undefined ? null : value;
		}
		return dataset;
	}

	update_links() {
		let container = this;
		function ahref(category, href) {
			container.elements[category].href = href;
		}
		function remove_hash(canonical) {
			let hash_at = canonical.indexOf('#');
			return hash_at === -1 ? canonical : canonical.substr(0,hash_at);
		}

		let dataset = this.fetch_audiotag_dataset();

		let url = (dataset.canonical === undefined ? '' : remove_hash(dataset.canonical))
					+ `#${this.audiotag.id}` 
					+ ( this.audiotag.currentTime === 0 
							? ''
							: `&t=${convert.SecondsInTime(this.audiotag.currentTime)}`
						);

		let _url = encodeURI(absolutize_url(url));
		let _twitter = '';
		if ((dataset.twitter !== undefined) && (dataset.twitter[0]==='@')) {
			_twitter = `&via=${dataset.twitter.substring(1)}`;
		}
		ahref('twitter', `https://twitter.com/share?text=${dataset.title}&url=${_url}${_twitter}`);
		ahref('facebook', `https://www.facebook.com/sharer.php?t=${dataset.title}&u=${_url}`);
		ahref('email', `mailto:?subject=${dataset.title}&body=${_url}`);
		ahref('link', this.audiotag.currentSrc);
	}

	show_interface(mode) {
		this.container.classList.remove('show-main', 'show-share', 'show-error');
		this.container.classList.add('show-'+mode);
	}
	show_actions(event) {
		let container = (event !== undefined) ?
				CPU_Audio.find_container(event.target) :
				this;
		container.show_interface('share');
		container.update_links();
	}
	show_main(event) {
		let container = (event !== undefined) ?
				CPU_Audio.find_container(event.target) :
				this;
		container.show_interface('main');
	}

	add_id_to_audiotag() {
		if (this.audiotag.id === '') {
			this.audiotag.id = CPU_Audio.dynamicallyAllocatedIdPrefix + String(CPU_Audio.count_element++);
		}
	}

	complete_template() {
		let dataset = this.fetch_audiotag_dataset();

		this.elements['canonical'].href = dataset.canonical;

		if (dataset.title === null) {
			this.elements['canonical'].classList.add('untitled')
			dataset.title = cpu_i18n['untitled']
		} else {
			this.elements['canonical'].classList.remove('untitled')
		}
		this.elements['canonical'].innerText = dataset.title; 
		this.elements['poster'].src = dataset.poster;
	}
	attach_audiotag_to_controller(audiotag) {
		this.audiotag = audiotag;

		this.add_id_to_audiotag()
		this.complete_template();

		// throw simplified event
		trigger.update({target : this.audiotag});
	}
	build_chapters(event) {
		let self = this;

		if (event !== undefined) {
			// Chrome load <track> afterwards, so an event is needed, and we need to recatch our CPU api to this event
			self = CPU_Audio.find_container(event.target);
		}

		if (self.element.tagName !== CpuAudioTagName) {
			// we will only build (now) the chapter list for <cup-audio>
			return;
		}

		let chapters_element = self.elements['chapters'];
		chapters_element.innerHTML = '';
		if ((!self.audiotag.textTracks) || (self.audiotag.textTracks.length === 0)) {
			return;
		}

		for (let tracks of self.audiotag.textTracks) {
			
			if ((tracks.kind === 'chapters') && (tracks.cues !== null)) {
				tracks.addEventListener('cuechange', function(event) {
					// ugly, but best way to catch the DOM element
					trigger.cuechange(event, chapters_element);
				});
				for (let cue of tracks.cues) {
					let line = document.createElement('li');
					line.id  = cue.id;
					line.classList.add('cue');
					let cuepoint = convert.SecondsInTime(cue.startTime);
					let cuetime = convert.SecondsInColonTime(cue.startTime);
					line.innerHTML = `<a href="#${self.audiotag.id}&t=${cuepoint}" tabindex="0">
										<strong>${cue.text}</strong>
										<span>${cuetime}</span>
									</a>`;
					self.elements['chapters'].append(line);
				}
			}
		}
	}
	build_controller() {

		this.element.classList.add(this.classname);
		//this.tabIndex = 0 // see http://snook.ca/archives/accessibility_and_usability/elements_focusable_with_tabindex and http://www.456bereastreet.com/archive/201302/making_elements_keyboard_focusable_and_clickable/

		// the following mess is to simplify sub element declaration and selection
		let controller = this;
		querySelector_apply('*', function(element){
			element.classList.forEach(function(this_class) {
				if (controller.elements[this_class] === undefined) {
					controller.elements[this_class] = element;
				}
			});
		}, this.element.shadowRoot);

		let cliquables = {
			'pause'		: trigger.play,
			'play'		: trigger.pause,
			'time'		: trigger.throbble,
			'actions'	: this.show_actions,
			'back' 		: this.show_main,
			'poster'	: this.show_main,
		};
		for (let that in cliquables) {
			this.elements[that].addEventListener('click', cliquables[that]);
		}
		// key management
		this.element.addEventListener('keydown', trigger.key);
		// not working correctly :/
		this.elements['control'].addEventListener('keydown', trigger.keydownplay);
		// throbber management
		let timeline_element = this.elements['time'];
		let do_events = {
			'mouseover' : true,
			'mousemove' : true,
			'mouseout'  : false,

			'touchstart'  : true,
			// 'touchmove'   : true,
			'touchend'    : false,
			'touchcancel' : false,
		}
		for(let event_name in do_events) {
			timeline_element.addEventListener(
				event_name,
				do_events[event_name] ? trigger.hover : trigger.out);				
		}
		this.show_main();
		this.build_chapters();
	}
};


// Controller without assigned audio element, i.e. global page controller
class CpuControllerElement extends HTMLElement {

	constructor() {
		// Always call super first in constructor
		super();

		if (not_screen_context()) {
			// I'm not in a screen context, as a braille surface
			// Sorry, but your browser's native controls are surely more accessible
			this.remove();
			return ;
		}

		if (this.tagName === CpuAudioTagName) {
			if (this.querySelector('audio[controls]') === null) {
				// Graceful degradation : do not start if no media element OR no native controls
				console.warn(`Tag <${CpuAudioTagName}> without <audio controls>.\nSee https://github.com/dascritch/cpu-audio/blob/master/index.html for a correct installation.`);
				this.remove();
				return;
			}
		}

		template =  thisDoc.querySelector('template');
		shadow_element = this.attachShadow({mode: 'open'});
		shadow_element.innerHTML = template.innerHTML;
	}

	connectedCallback() {
		if (not_screen_context()) {
			return ;
		}
		this.CPU = new CPU_element_api(
			this,
			this.shadowRoot.querySelector('.interface')
		);
		if (!this.CPU.audiotag) {
			CPU_Audio.global_controller = this.CPU;
			this.CPU.audiotag = window.document.querySelector('cpu-audio audio');
		}

		this.CPU.build_controller();
		querySelector_apply('.canonical', element_prevent_link_on_same_page);

		this.CPU.attach_audiotag_to_controller(this.CPU.audiotag);

		let mode = this.getAttribute('mode');
		mode = mode !== null ? mode : 'default'
		this.CPU.elements['interface'].classList.add(`mode-${mode}`)
	}

	disconnectedCallback() {
	}

}

// Controller with assigned audio element
class CpuAudioElement extends CpuControllerElement {

	connectedCallback() {

		this._audiotag = this.querySelector('audio[controls]');
		if (this._audiotag === null) {
			return;
		}

		// copying personalized data to audio tag
		for (let key in CPU_Audio.default_dataset) {
			let value = this.getAttribute(key);
			if (value !== null) {
				this._audiotag.dataset[key] = value;
			}
		}
		super.connectedCallback();

		CPU_Audio.connect_audiotag(this.CPU.audiotag);

		// If we didn't have a timecode hash at loading document, try to recall previous interrupted player
		//CPU_Audio.recall_stored_play({target : this.CPU.audiotag});

	}

}

// expose API in parent page DOM
window.document.CPU = CPU_Audio;

window.addEventListener('hashchange', trigger.hashOrder, false);
trigger.hashOrder({ at_start : true });

if (!is_decent_browser_for_webcomponents()) {
	console.error(`<${CpuAudioTagName}> WebComponent may NOT behave correctly. Only timecode hash links are activated.\nSee https://github.com/dascritch/cpu-audio/blob/master/index.html for details`);
	querySelector_apply('audio[controls]', CPU_Audio.recall_audiotag);
	window.document.body.classList.add('cpu-audio-without-webcomponents');
} else {
	window.customElements.define(CpuAudioTagName.toLowerCase(), CpuAudioElement);
	window.customElements.define(CpuControllerTagName.toLowerCase(), CpuControllerElement);	
	window.document.body.classList.add('cpu-audio-with-webcomponents');
}
})();
</script>
