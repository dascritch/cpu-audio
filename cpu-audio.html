<!--

Cpu-Audio, an extension to the hash system to address timecode into audio/video elements
Copyright (C) 2014-2018 Xavier "dascritch" Mouton-Dubosc

Previously TimecodeHash, then OndeMirroir Audio Tag

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

project repository : https://github.com/dascritch/ondemiroir-audio-tag
blog post : http://dascritch.net/post/2014/09/03/Timecodehash-%3A-Lier-vers-un-moment-d-un-sonore

Note.

Bugs restants :
- au rechargement, seul le premier player est pris en compte
- sur Chrome, une erreur media n'est pas de suite remontée


Fonctions retirées :
- playlist
- i18n
-->

<style>
	/* Global default style, usign var. Integrators may override them */
	:root {
		--cpu-font-family : Lato, "Open Sans", "Segoe UI", Frutiger, "Frutiger Linotype", "Dejavu Sans", "Helvetica Neue", Arial, sans-serif;
		--cpu-font-size : 15px;
		--cpu-background : #555;
		--cpu-color : #ccc;
		--cpu-link-color : #aaf;
		--cpu-playing-background : #444;
		--cpu-playing-color : #ddd;
		--cpu-playing-link-color : #bbf;
		--cpu-error-background : #a00 ;
		--cpu-error-color : #ff7 ;
		--cpu-popup-background : #aaa;
		--cpu-popup-color : #333;

		/** TODO */
		--poster-fallback : '//dascritch.net/themes/DSN13/img/entete1.svg';
	}
</style>

<template>
<style>
.cpu-audio {
	font-family : var(--cpu-font-family) !important;
	font-size : var(--cpu-font-size) !important;
}

.cpu-audio, * {
	line-height : 1.2 !important;
	border : none !important;
	padding : 0 !important;
	margin : 0 !important;
	transition : none !important;
	moz-user-select: none;
	ms-user-select: none;
	webkit-user-select: none;
	user-select: none;
}

.cpu-audio {
	display : flex;
	background : var(--cpu-background);
	color : var(--cpu-color);
	height : 64px;
}

.act-error {
	color : #cc0;
}

a {
	color : var(--cpu-link-color);
	border : none !important;
	text-decoration : none;
}

svg {
  	fill : #ffffff;
  	width:64px;
	height : 64px;
}

a:hover {
	color : var(--cpu-background);
	background : var(--cpu-link-color);
}

a:hover svg {
	fill : var(--cpu-background);
}

.act-play {
	background : var(--cpu-playing-background);
	color : var(--cpu-playing-color);
}

.act-play a {
	color : var(--cpu-playing-link-color);
}

.act-play a:hover {
	color : var(--cpu-playing-background);
	background : var(--cpu-playing-link-color);
}

.act-play a:hover svg {
	fill : var(--cpu-playing-background);
}

.show-error {
	background : var(--cpu-error-background);
	color : var(--cpu-error-color);
}

.control,
.actions,
.back {
	flex : 0 0 64px;
	width : 64px;
	max-height : 64px;
	height : 100%;
	text-align : center;
	vertical-align : middle;
}

.actions,
.back {
	cursor : pointer;
}

.loading, .play, .pause,
.show-main .pageshare, .show-main .pageerror,
.show-share .pagemain, .show-share .pageerror,
.show-error .pagemain, .show-error .pageshare {
	display : none;
}

.act-loading .loading,
.act-play .play,
.act-pause .pause {
	display : block;
}

.show-share .pageshare,
.show-main .pagemain,
.share {
	flex : 1 1 100%;
	display : flex;
	align-items: center;
}

.act-loading .loading circle:nth-child(1) {
  animation: pulse0 2s infinite;
}

.act-loading .loading circle:nth-child(2) {
  animation: pulse1 2s infinite;
}

.act-loading .loading circle:nth-child(3) {
  animation: pulse2 2s infinite;
}

@keyframes pulse0 {
  0% {
    opacity : 1;
  }
  50% {
    opacity : 0;
  }
  100% {
    opacity : 1;
  }
}

@keyframes pulse1 {
  0% {
    opacity : 0.75;
  }
  12% {
    opacity : 1;
  }
  62% {
    opacity : 0;
  }
  100% {
    opacity : 0.75;
  }
}

@keyframes pulse2 {
  0% {
    opacity : 0.5;
  }
  25% {
    opacity : 1;
  }
  75% {
    opacity : 0;
  }
  100% {
    opacity : 0.5;
  }
}

@keyframes pulse3 {
  0% {
    opacity : 0.25;
  }
  37% {
    opacity : 1;
  }
  87% {
    opacity : 0;
  }
  100% {
    opacity : 0.5;
  }
}

.cover {
	width : 64px;
 }

.poster {
	width : 64px;
	height : 64px;
	object-fit: contain;
}

.loading svg, .play svg, .pause svg, .actions svg {
	vertical-align : middle;
	max-width : 100%;
	max-height : 100%;
}

.titleline {
	display : flex;
}

.about, .title {
	flex : 1 1 100%;
	position : relative;
}

.title a {
  display : block;
	text-overflow : ellipsis;
	max-height: 48px;
	overflow: hidden;

}

.elapse {
	flex : 1 0 170px;
	text-align : right;
}

.time {
	background : black;
	width : 100%;
	height : 10px;
	display : block;
	border-radius : 4px;
	position : relative;
	cursor:none;
}

.loadingline,
.elapsedline {
	background : white;
	height : 10px ;
	display : block ;
	position : absolute;
	left : 0;
	border-radius : 4px;
	pointer-events : none;
}

.elapsedline {
	z-index : 2;
}

.act-loading .loadingline {
	background : grey;
	/*
	background: repeating-linear-gradient(135deg, #bbb 0, #999 5px, #999 45px, #ddd 55px, #ddd 95px, #bbb 100px);
  animation: progressIndeterminate 950ms linear infinite;
  */
}

.share {
	text-align : center;
}

.share a {
	height : 64px;
}

.share a, .share div {
	flex : 1 0;
	color : white;
	text-decoration : none;
	overflow : hidden;
	text-overflow : clip;
}

.share svg {
	vertical-align : middle;
  width:32px;
  height : 32px;
}

.twitter {background : #4DB5F4}
.facebook {background : #5974CC}
.email {background : #CC0000}
.link {background : #77F}

.popup {
	position: absolute;
	transform: translate(-25px, -15px);
	z-index : 127;
	min-width : 50px;
	font-size : 11px;
	text-align : center;
	padding : 8px;
	border-radius: 4px;
	background : var(--cpu-popup-background);
	color : var(--cpu-popup-color);
	opacity : 0;
	transition : opacity 1s;
	pointer-events : none;
	/* absolute pos, need to repeat it →  https://developer.mozilla.org/en-US/docs/Web/CSS/user-select */
	moz-user-select: none;
	ms-user-select: none;
	webkit-user-select: none;
	user-select: none;
	box-shadow: black 2px 2px
}

.popup:before {
	content:"";
	position: absolute;
	left: 20px;
	bottom: -8px;
	height : 0;
	width: 0;
	border-top: 8px solid var(--cpu-popup-background);
	border-left: 4px solid transparent;
	border-right: 4px solid transparent;
	pointer-events : none;
}

@media screen and (max-width: 640px) {
	.cpu-audio {
		height : 32px;
		font-size : 12px;
	}

  .nosmall {
		display : none;
  }

  .control,
	.actions {
		flex : 0 0 32px;
		height : 32px;
		width : 32px;
	}

	svg {
  		width:32px;
		height : 32px;
	}

	.title a {
		max-height : 16px;
	}

  .elapse {
    flex : 1 0 80px;
		max-height : 16px;
  }

  .share a {
		height : 32px;
	}
}

@media screen and (max-width: 319px) {
	.elapse {
		display : none;
	}
}

@media print {
	.cpu-audio {
		display : none;
	}
}
</style>

<div class="cpu-audio">
	<img class="poster nosmall" src="" alt="" />
	<div class="pageerror"></div>
	<div class="pagemain">
		<div class="control">
			<div class="loading" title="Chargement en cours">
				<svg viewBox="0 0 32 32">
					<circle cx="6" cy="22" r="4" fill="#777777" />
					<circle cx="16" cy="22" r="4" fill="#777777" />
					<circle cx="26" cy="22" r="4" fill="#777777" />
				</svg>
			</div>
			<a class="play" title="Lecture">
				<svg viewBox="0 0 32 32">
					<path d="M 6,6 12.667,6 12.667,26 6,26 z" />
					<path d="M 19.333,6 26,6 26,26 19.333,26 z" />
				</svg>
			</a>
			<a class="pause" title="Pause">
				<svg viewBox="0 0 32 32">
					<path d="M 6,6 6,26 26,16 z" />
				</svg>
			</a>
		</div>
		<div class="about">
			<div class="titleline">
				<div class="title"><a href="#" class="canonical"></a></div>
				<a class="elapse">…</a>
			</div>
			<div class="line">
				<div class="time">
					<div class="loadingline"></div>
					<div class="elapsedline"></div>
					<time class="popup">--:--</time>
				</div>
			</div>
		</div>
		<a class="actions">
			<svg viewBox="0 0 32 32">
				<circle cx="12" cy="10" r="4" /><circle cx="12" cy="22" r="4" /><circle cx="23" cy="16" r="4" /><polygon points="12,8 24,14 24,18 12,12"/><polygon points="12,20 24,14 24,18 12,24"/>
			</svg>
		</a>
	</div>
	<div class="pageshare">
		<div class="share">
			<a href="#" target="social" class="twitter nosmall" title="Partager sur Twitter">
				<svg viewBox="0 0 32 32">
					<path d="M 25.941,9.885 C 25.221,10.205 24.448,10.422 23.637,10.520 24.465,10.020 25.101,9.230 25.401,8.288 24.626,8.750 23.768,9.086 22.854,9.267 22.122,8.483 21.080,7.993 19.926,7.993 c -2.215,0 -4.011,1.806 -4.011,4.034 0,0.316 0.035,0.623 0.103,0.919 -3.333,-0.168 -6.288,-1.774 -8.267,-4.215 -0.345,0.596 -0.542,1.289 -0.542,2.028 0,1.399 0.708,2.634 1.784,3.358 -0.657,-0.020 -1.276,-0.202 -1.816,-0.504 -3.98e-4,0.016 -3.98e-4,0.033 -3.98e-4,0.050 0,1.954 1.382,3.585 3.217,3.955 -0.336,0.092 -0.690,0.141 -1.056,0.141 -0.258,0 -0.509,-0.025 -0.754,-0.072 0.510,1.602 1.991,2.769 3.746,2.801 -1.372,1.082 -3.102,1.726 -4.981,1.726 -0.323,0 -0.642,-0.019 -0.956,-0.056 1.775,1.144 3.883,1.812 6.148,1.812 7.377,0 11.411,-6.147 11.411,-11.478 0,-0.174 -0.004,-0.348 -0.011,-0.522 0.783,-0.569 1.463,-1.279 2.001,-2.088 z" />
				</svg>
				<span>Partager sur Twitter</span>
			</a>
			<a href="#" target="social" class="facebook nosmall" title="Partager sur Facebook">
				<svg viewBox="0 0 32 32">
					<path d="m 21.117,16.002 -3.728,0 0,10.027 -4.297,0 0,-10.027 -2.070,0 0,-3.280 2.070,0 0,-2.130 c 0,-2.894 1.248,-4.616 4.652,-4.616 l 3.922,0 0,3.549 -3.203,0 c -0.950,-0.001 -1.068,0.495 -1.068,1.421 l -0.005,1.775 4.297,0 -0.568,3.280 0,2.34e-4 z" />
				</svg>
				<span>Partager sur Facebook</span>
			</a>
			<a href="#" target="social" class="email" title="Partager par e-mail">
				<svg viewBox="0 0 32 32">
					<path d="m 8.030,8.998 15.920,0 c 0.284,0 0.559,0.053 0.812,0.155 l -8.773,9.025 -8.773,-9.026 c 0.253,-0.101 0.528,-0.155 0.812,-0.155 z m -1.990,12.284 0,-10.529 c 0,-0.036 0.002,-0.073 0.004,-0.109 l 5.835,6.003 -5.771,5.089 c -0.045,-0.146 -0.068,-0.298 -0.069,-0.453 z m 17.910,1.754 -15.920,0 c -0.175,0 -0.348,-0.020 -0.514,-0.060 l 5.662,-4.993 2.811,2.892 2.811,-2.892 5.662,4.993 c -0.165,0.039 -0.338,0.060 -0.514,0.060 z m 1.990,-1.754 c 0,0.155 -0.023,0.307 -0.068,0.453 l -5.771,-5.089 5.835,-6.003 c 0.002,0.036 0.004,0.073 0.004,0.109 z" />
				</svg>
				<span>Partager par e-mail</span>
			</a>
			<a href="#" target="social" class="link" title="Télécharger">
				<svg viewBox="0 0 32 32">
					<path d="M 6,6 26,6 16,26 z" /><rect x="6" y="22" width="20" height="4" />
				</svg>
				<span>Télécharger</span></a>
			<a class="back" title="Annuler">Annuler</a>
		</div>
	</div>
</div>
</template>

<script>
(() => {
  'use strict';

  const thisDoc = (document._currentScript || document.currentScript).ownerDocument;
  const twitterVia = 'dascritch';
  const cpuI18n = {
    untitled: '(sans titre)',
    cover: 'pochette',
    more: 'Partager',
    twitter: 'Partager sur Twitter',
    facebook: 'Partager sur Facebook',
    eMail: 'Partager par e-mail',
    download: 'Télécharger',
    back: 'Annuler',
    media_err_aborted: 'Vous avez annulé la lecture.',
    media_err_network: 'Une erreur réseau a causé l\'interruption du téléchargement.',
    media_err_decode: 'La lecture du sonore a été annulée suite à des problèmes de corruption ou de fonctionnalités non supportés par votre navigateur.',
    media_err_src_not_supported: 'Le sonore n\'a pu être chargé, soit à cause de sourcis sur le serveur, le réseau ou parce que le format n\'est pas supporté.',
    media_err_unknow: 'Erreur due à une raison inconnue',
  };
  const onDebug = (callbackFx) => {
    // This is needed for testing, as we now run in async tests.
    if (typeof callbackFx === 'function') {
      callbackFx();
    }
  };
  const querySelectorApply = (selector, callback, subtree) => {
    subtree = subtree === undefined ? document : subtree;
    // Explication de cette construction : https://coderwall.com/p/jcmzxw.
    [].forEach.call(subtree.querySelectorAll(selector), callback);
  };
  const convert = {
    _units: {
      d: 86400,
      h: 3600,
      m: 60,
      s: 1,
    },

    TimeInSeconds: (givenTime) => {
      let seconds = 0;

      if (/^\d+$/.test(givenTime)) {
        seconds = Number(givenTime);
      }
      else {
        seconds = (givenTime.indexOf(':') === -1) ? this.SubunitTimeInSeconds(givenTime) : this.ColonTimeInSeconds(givenTime);
      }

      return seconds;
    },

    SubunitTimeInSeconds: (givenTime) => {
      let seconds = 0;

      for (const key in convert._units) {
        if ((convert._units.hasOwnProperty(key)) && (givenTime.indexOf(key) !== -1)) {
          const atoms = givenTime.split(key);
          seconds += Number(atoms[0].replace(/\D*/g, '')) * convert._units[key];
          givenTime = atoms[1];
        }
      }

      return seconds;
    },

    ColonTimeInSeconds: (givenTime) => {
      let seconds = 0;
      const atoms = givenTime.split(':');
      const _convert = [1, 60, 3600, 86400];

      for (let pos = 0; pos < atoms.length; pos++) {
        seconds += Number(atoms[pos]) * _convert[((atoms.length - 1) - pos)];
      }

      return seconds;
    },

    SecondsInTime: (givenSeconds) => {
      let converted = '';
      let inned = false;

      for (const key in convert._units) {
        if (convert._units.hasOwnProperty(key)) {
          const multiply = convert._units[key];

          if ((givenSeconds >= multiply) || (inned)) {
            inned = true;
            const digits = Math.floor(givenSeconds / multiply);
            converted += digits + key;
            givenSeconds -= digits * multiply;
          }
        }
      }

      if (converted === '') {
        converted = '0s';
      }

      return converted;
    },
  };
  const trigger = {
    hashOrder: (hashcode, callbackFx) => {
      let atStart = true;
      if (typeof hashcode !== 'string') {
        atStart = 'at_start' in hashcode;
        hashcode = location.hash.substr(1);
      }
      let hash = '';
      let timecode = '';
      const segments = hashcode.split('&');
      let autoplay = false;

      for (const _id in segments) {
        const parameter = segments[_id];

        if (parameter.indexOf('=') === -1) {
          // Should reference to the ID of the element.
          hash = parameter;
        }
        else {
          // Should be a key=value parameter.
          const atoms = parameter.split('=');
          const pKey = atoms[0];
          const pValue = atoms[1];
          switch (pKey) {
            case 't':
              // Is a time index.
              timecode = pValue;
              // We make autoplay at requested timecode, simplier of the user.
              autoplay = true;
              break;
            case 'autoplay':
              // Is a card from a social network, run now.
              if (pValue === '1') {
                autoplay = true;
              }
              break;
            case 'auto_play':
              // Is a card from a social network, run now.
              if (pValue === 'true') {
                autoplay = true;
              }
              break;
            default:
              break;
          }
        }
      }

      if ((timecode === '') || ((atStart) && (!autoplay))) {
        // This is a normal anchor call. Go back to normal behaviour.
        onDebug(callbackFx);
        return false;
      }

      CPU_Audio.jumpIdAt(hash, timecode, callbackFx);
      return true;
    },

    hover: (event) => {
      const container = CPU_Audio.find_container(event.target);
      const targetRect = event.target.getClientRects()[0];
      const relLeft = targetRect.left;
      const ratio = (event.clientX - relLeft) / event.target.clientWidth;
      const seekedTime = ratio * container.audiotag.duration;
      container.showThobberAt(seekedTime);
    },

    out: (event) => {
      const container = CPU_Audio.find_container(event.target);
      container.hideThrobber();
    },

    throbble: (event) => {
      let at = 0;
      const container = CPU_Audio.find_container(event.target);
      const { audiotag } = container;
      if (event.at !== undefined) {
        at = event.at;
      }
      else {
        // Normal usage.
        const relLeft = event.target.getClientRects()[0].left;
        const ratio = (event.clientX - relLeft) / event.target.clientWidth;
        at = ratio * audiotag.duration;
      }
      CPU_Audio.seekElementAt(audiotag, at);
      trigger.play(event);
    },

    pause: (event, audiotag) => {
      if (audiotag === undefined) {
        audiotag = CPU_Audio.find_container(event.target).audiotag;
      }
      audiotag.pause();
      CPU_Audio.current_audiotag_playing = null;
      window.localStorage.removeItem(audiotag.currentSrc);
    },

    play: (event, audiotag) => {
      if (audiotag === undefined) {
        audiotag = CPU_Audio.find_container(event.target).audiotag;
      }
      if ((CPU_Audio.only_play_one_audiotag) && (CPU_Audio.current_audiotag_playing)) {
        trigger.pause(undefined, CPU_Audio.current_audiotag_playing);
      }

      CPU_Audio.current_audiotag_playing = audiotag;
      if (CPU_Audio.global_controller) {
        CPU_Audio.global_controller.attachAudiotagToController(CPU_Audio.current_audiotag_playing);
        CPU_Audio.global_controller.showMain();
      }
      audiotag.play();
    },

    key: (event) => {
      const container = event.target;

      function seekRelative(seconds) {
        event.at = container.audiotag.currentTime + seconds;
        container.showThobberAt(container, event.at);
        trigger.throbble(event);
        container.hideThrobberLater();
      }

      switch (event.keyCode) {
        // Can't use enter : standard usage.
        case 27: // esc
          CPU_Audio.seekElementAt(container.audiotag, 0);
          trigger.pause(undefined, container.audiotag);
          break;
        case 32: // space
          container.audiotag.paused ? trigger.play(undefined, container.audiotag) : trigger.pause(undefined, container.audiotag);
          break;
        case 35: // end
          CPU_Audio.seekElementAt(container.audiotag, container.audiotag.duration);
          break;
        case 36: // home
          CPU_Audio.seekElementAt(container.audiotag, 0);
          break;
        case 37: // ←
          seekRelative(-CPU_Audio.keymove);
          break;
        case 39: // →
          seekRelative(+CPU_Audio.keymove);
          break;
        default:
          break;
      }
    },

    update: (event) => {
      const audiotag = event.target;
      audiotag.CPU_update();
      if (!audiotag.paused) {
        window.localStorage.setItem(audiotag.currentSrc, String(audiotag.currentTime));
      }
    },
  };
  const absolutizeUrl = (url) => {
    const testElement = document.createElement('a');
    testElement.href = url;
    return testElement.href;
  };
  const notScreenContext = () => {
    return !window.matchMedia('screen').matches;
  };
  const preventLinkOnSamePage = (event) => {
    if (absolutizeUrl(window.location.href) !== absolutizeUrl(event.target.href)) {
      return;
    }
    event.preventDefault();
  };
  const elementPreventLinkOnSamePage = (element) => {
    element.addEventListener('click', preventLinkOnSamePage);
  };
  const _isEvent = (event) => {
    // Is this event really triggered via a native event ?
    return event.preventDefault !== undefined;
  };
  const CPU_Audio = {
    // Global object for global controller.
    keymove: 5,
    only_play_one_audiotag: true,
    current_audiotag_playing: null,
    // This one, later.
    global_controller: null,
    selector_container: 'cpu-audio',
    selector_interface: '.cpu-audio',
    dynamicallyAllocatedIdPrefix: 'CPU-Audio-tag-',
    count_element: 0,

    connect_audiotag(audiotag) {
      // See https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events for list of events.
      [
        'ready', 'load', 'loadeddata', 'canplay', 'abort',
        'error', 'stalled', 'suspend', 'emptied',
        'play', 'playing', 'pause', 'suspend', 'ended',
        'durationchange', 'loadedmetadata', 'progress', 'timeupdate', 'waiting',
      ].forEach((on) => {
        audiotag.addEventListener(on, trigger.update);
      });

      audiotag.addEventListener('loadedmetadata', CPU_Audio.recall_stored_play);
      // Those ↓ for PHRACKING SAFARI.
      audiotag.addEventListener('ready', CPU_Audio.recall_stored_play);
      audiotag.addEventListener('canplay', CPU_Audio.recall_stored_play);

      // Ask ASAP metadata about media.
      // We have to set in HTML code preload="none" due to a very laggy behaviour in HTTP2
      // https://stackoverflow.com/questions/14479413/chrome-ignoring-audio-preload-metadata
      if (audiotag.preload === '') {
        audiotag.preload = 'metadata';
      }
      audiotag.load();
      if (this.dontHideAudioTag === false) {
        audiotag.hidden = true;
        // PHRACK SAFARI
        audiotag.removeAttribute('controls');
      }
    },

    jumpIdAt: (hash, timecode, callbackFx) => {
      function doElementPlay(event) {
        const tag = event.target;
        trigger.play(undefined, tag);
        if (_isEvent(event)) {
          tag.removeEventListener('canplay', doElementPlay, true);
        }
        onDebug(callbackFx);
      }

      function doNeedleMove(event) {
        const audiotag = event.target;

        if (_isEvent(event)) {
          audiotag.removeEventListener('loadedmetadata', doNeedleMove, true);
        }

        const secs = convert.TimeInSeconds(timecode);
        CPU_Audio.seekElementAt(audiotag, secs);

        if (audiotag.readyState >= audiotag.HAVE_FUTURE_DATA) {
          doElementPlay({ target: audiotag });
        }
        else {
          audiotag.addEventListener('canplay', doElementPlay, true);
        }
        trigger.update({ target: audiotag });
      }

      const audiotag = (hash !== '') ? document.getElementById(hash) : document.querySelector(this.selector_fallback);

      if ((audiotag === undefined) || (audiotag === null) || (audiotag.currentTime === undefined)) {
        return false;
      }

      if (audiotag.readyState < audiotag.HAVE_CURRENT_DATA) {
        audiotag.addEventListener('loadedmetadata', doNeedleMove, true);
        audiotag.load();
      }
      else {
        doNeedleMove({ target: audiotag });
      }
      trigger.update({ target: audiotag });
    },

    find_container: (child) => {
      if (child.tagName === CPU_Audio.selector_container.toUpperCase()) {
        return child;
      }
      // DOMnode.closest won't work in too old browsers
      // CF https://caniuse.com/#search=closest
      return this.find_interface(child).parentNode.host;
    },

    find_interface: (child) => {
      return child.closest(CPU_Audio.selector_interface);
    },

    seekElementAt: (audiotag, seconds) => {
      if (audiotag.fastSeek !== undefined) {
        audiotag.fastSeek(seconds);
        // Firefox doesn't see fastSeek.
      }
      else {
        try {
          // But can set currentTime.
          audiotag.currentTime = seconds;
        }
        catch (e) {
          // Exept sometimes, so you must use standard media fragment.
          audiotag.src = `${audiotag.currentSrc.split('#')[0]}#t=${seconds}`;
        }
      }

      audiotag.CPU_controller().updateLoading(seconds);
    },

    recall_stored_play: (event) => {
      if (CPU_Audio.current_audiotag_playing !== null) {
        return;
      }
      const audiotag = event.target;
      const lasttimecode = Number(window.localStorage.getItem(audiotag.currentSrc));
      // TODO and no hashed time
      if (lasttimecode > 0) {
        CPU_Audio.seekElementAt(audiotag, lasttimecode);
        trigger.play(undefined, audiotag);
      }
    },
  };

  // Extensions on media element.
  HTMLAudioElement.prototype.CPU_controller = () => {
    return this.closest(CPU_Audio.selector_container);
  };

  HTMLAudioElement.prototype.CPU_update = () => {
    if (this.CPU_controller().update) {
      this.CPU_controller().update();
    }

    if (CPU_Audio.global_controller) {
      CPU_Audio.global_controller.update();
    }
  };

  // Controller without assigned audio element, i.e. global page controller.
  class CpuControllerElement extends HTMLElement {
    constructor() {
      // Always call super first in constructor.
      super();

      if (notScreenContext()) {
        // I'm not in a screen context, as a braille surface.
        // Sorry, but your browser's native controls are surely more accessible.
        return;
      }

      // Self variables.
      this.dontHideAudioTag = false;
      this.poster_fallback = '//dascritch.net/themes/DSN13/img/entete1.svg';
      this._elements = {};
      this.audiotag = null;

      const shadowElement = this.attachShadow({ mode: 'open' });
      shadowElement.innerHTML = thisDoc.querySelector('template').innerHTML;
    }

    connectedCallback() {
      if (notScreenContext()) {
        return;
      }
      this.container = shadowElement.querySelector('.cpu-audio');
      this.build_controller();
      // TODO : Event should be set on controller,
      // with checking event.originalTarget.classlist.has().
      querySelectorApply('.canonical', elementPreventLinkOnSamePage);

      if (this.audiotag === null) {
        CPU_Audio.global_controller = this;
        this.audiotag = window.document.querySelector('cpu-audio audio');
      }
      this.attachAudiotagToController(this.audiotag);
    }

    updateActContainer(act) {
      this.container.classList.remove(
        'act-loading',
        'act-pause',
        'act-play',
      );
      this.container.classList.add(`act-${act}`);
    }

    updatePlaybutton() {
      if (this.audiotag.readyState < this.audiotag.HAVE_CURRENT_DATA) {
        this.updateActContainer('loading');
        return;
      }

      this.updateActContainer(this.audiotag.paused ? 'pause' : 'play');
    }

    updateLine(type, seconds) {
      const { duration } = this.audiotag;
      this._elements[`${type}line`].style.width = duration === 0 ? 0 : `${100 * seconds / duration}%`;
    }

    updateBuffered() {
      let end = 0;
      const { buffered } = this.audiotag;

      for (let segment = 0; segment++; segment < buffered.length) {
        end = buffered.end(segment);
      }

      this.updateLine('elapsed', end);
    }

    updateTime() {
      const timecode = convert.SecondsInTime(this.audiotag.currentTime);
      let linkTo = `${absolutizeUrl(this.audiotag.dataset.canonical)}#`;
      linkTo += this.audiotag.id ? `${this.audiotag.id}&` : '';
      linkTo += `t=${timecode}`;

      const elapseElement = this._elements.elapse;
      elapseElement.href = linkTo;

      let totalDuration = '…';
      if (!isNaN(Math.round(this.audiotag.duration))) {
        totalDuration = convert.SecondsInTime(Math.round(this.audiotag.duration));
      }

      elapseElement.innerHTML = `${timecode} <span class="nosmall"> / ${totalDuration}</span>`;
      this.updateLine('loading', this.audiotag.currentTime);
      this.updateBuffered();
    }

    updateLoading(seconds) {
      this.updateLine('loading', seconds);
      this.updateActContainer('loading');
    }

    updateError() {
      // NOTE : this is not working, even on non supported media type.
      // Chrome logs an error « Uncaught (in promise) DOMException: Failed to load because no supported source was found. »
      // but don't update message.
      if (this.audiotag.error !== null) {
        this.showInterface('error');
        const { pageerror } = this._elements;

        switch (this.audiotag.error.code) {
          case this.audiotag.error.MEDIA_ERR_ABORTED:
            pageerror.innerText = cpuI18n.media_err_aborted;
            break;
          case this.audiotag.error.MEDIA_ERR_NETWORK:
            pageerror.innerText = cpuI18n.media_err_network;
            break;
          case this.audiotag.error.MEDIA_ERR_DECODE:
            pageerror.innerText = cpuI18n.media_err_decode;
            break;
          case this.audiotag.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
            pageerror.innerText = cpuI18n.media_err_src_not_supported;
            break;
          default:
            pageerror.innerText = cpuI18n.media_err_unknow;
            break;
        }

        pageerror.innerText = 'error';
        return true;
      }

      return false;
    }

    update() {
      if (!this.updateError()) {
        this.updatePlaybutton();
        this.updateTime();
      }
    }

    showThobberAt(seekedTime) {
      if (this.audiotag.duration < 1) {
        // Do not try to show if no metadata.
        return;
      }
      const phylactere = this._elements.popup;

      phylactere.style.opacity = 1;
      phylactere.style.left = (100 * seekedTime / this.audiotag.duration) + '%';
      phylactere.innerHTML = convert.SecondsInTime(seekedTime);
    }

    hideThrobber() {
      const phylactere = this._elements.popup;
      phylactere.style.opacity = 0;
    }

    hideThrobberLater() {
      const phylactere = this._elements.popup;
      if (phylactere._hider) {
        window.clearTimeout(phylactere._hider);
      }
      phylactere._hider = window.setTimeout(this.hideThrobber, 1000);
    }

    updateLinks() {
      const container = this;
      function ahref(category, href) {
        container._elements[category].href = href;
      }
      function removeHash(canonical) {
        const hashAt = canonical.indexOf('#');
        return hashAt === -1 ? canonical : canonical.substr(0, hashAt);
      }

      const { canonical } = this.audiotag.dataset;
      const url = (canonical === undefined ? '' : removeHash(canonical))
          + `#${this.audiotag.id}`
          + (this.audiotag.currentTime === 0
            ? ''
            : `&t=${convert.SecondsInTime(this.audiotag.currentTime)}`
          );

      const _url = encodeURI(absolutizeUrl(url));
      const _title = encodeURI(this.audiotag.title);
      ahref('twitter', `https://twitter.com/share?text=${_title}&url=${_url}&via=${twitterVia}`);
      ahref('facebook', `https://www.facebook.com/sharer.php?t=${_title}&u=${_url}`);
      ahref('email', `mailto:?subject=${_title}&body=${_url}`);
      ahref('link', this.audiotag.currentSrc);
    }

    showInterface(mode) {
      this.container.classList.remove('show-main', 'show-share', 'show-error');
      this.container.classList.add('show-' + mode);
    }

    showActions(event) {
      const container = (event !== undefined) ? CPU_Audio.find_container(event.target) : this;
      container.showInterface('share');
      container.updateLinks();
    }

    showMain(event) {
      const container = (event !== undefined) ? CPU_Audio.find_container(event.target) : this;
      container.showInterface('main');
    }

    elementAttribute(element, key, missing) {
      return (element.attributes[key] === undefined) ? missing : element.attributes[key].value;
    }

    addIdToContainer() {
      this.id = this.id !== '' ? this.id : (this.idPrefix + String(CPU_Audio.count_element++));
    }

    addIdToAudiotag() {
      if (this.audiotag.id === '') {
        this.audiotag.id = CPU_Audio.dynamicallyAllocatedIdPrefix + String(CPU_Audio.count_element++);
      }
    }

    completeTemplate() {
      let { canonical } = this.audiotag.dataset;
      if (canonical === undefined) {
        canonical = window.location.href;
      }
      this._elements.canonical.href = canonical;

      let { title } = this.audiotag.dataset;
      title = title === undefined ? cpuI18n.untitled : title;
      this._elements.canonical.innerText = title;
      this._elements.canonical.title = title;

      this._elements.poster.src = this.audiotag.dataset.poster;
    }

    attachAudiotagToController(audiotag) {
      this.audiotag = audiotag;
      this.addIdToAudiotag();
      this.completeTemplate();

      // Throw simplified event.
      trigger.update({ target: this.audiotag });
    }

    buildCtTroller() {
      this.classList.add(this.classname);
      // See http://snook.ca/archives/accessibility_and_usability/elements_focusable_with_tabindex and http://www.456bereastreet.com/archive/201302/making_elements_keyboard_focusable_and_clickable/.
      this.tabIndex = 0;
      // The following mess is to simplify sub element declaration and selection.
      this._elements = {};
      const controller = this;

      querySelectorApply('*', (element) => {
        element.classList.forEach((thisClass) => {
          if (controller._elements[thisClass] === undefined) {
            controller._elements[thisClass] = element;
          }
        });
      }, this.shadowRoot);

      const cliquables = {
        pause: trigger.play,
        play: trigger.pause,
        time: trigger.throbble,
        actions: this.showActions,
        back: this.showMain,
        poster: this.showMain,
      };

      for (const that in cliquables) {
        this._elements[that].addEventListener('click', cliquables[that]);
      }

      // Key management.
      this.addEventListener('keydown', trigger.key);
      // Throbber management.
      const timelineElement = this._elements.time;
      const doEvents = {
        mouseover: true,
        mousemove: true,
        mouseout: false,
        touchstart: true,
        touchend: false,
        touchcancel: false,
      };

      for (const eventName in doEvents) {
        timelineElement.addEventListener(eventName, doEvents[eventName] ? trigger.hover : trigger.out);
      }
      this.showMain();
    }
  }

  // Controller with assigned audio element.
  class CpuAudioElement extends CpuControllerElement {
    connectedCallback() {
      if (notScreenContext()) {
        return;
      }

      this.audiotag = this.querySelector('audio');
      // Copying personalized data to audio tag.
      for (const key of ['title', 'poster', 'canonical']) {
        this.audiotag.dataset[key] = this.dataset[key];
      }
      super.connectedCallback();

      CPU_Audio.connect_audiotag(this.audiotag);
      CPU_Audio.recall_stored_play({ target: this.audiotag });
    }
  }

  window.customElements.define('cpu-controller', CpuControllerElement);
  window.customElements.define(CPU_Audio.selector_container, CpuAudioElement);
  window.addEventListener('hashchange', trigger.hashOrder, false);
  trigger.hashOrder({ atStart: true });
})();
</script>
