<!--

Cpu-Audio, an extension to the hash system to address timecode into audio/video elements
Copyright (C) 2014-2018 Xavier "dascritch" Mouton-Dubosc

Previously TimecodeHash, then OndeMirroir Audio Tag

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

project repository : https://github.com/dascritch/ondemiroir-audio-tag
blog post : http://dascritch.net/post/2014/09/03/Timecodehash-%3A-Lier-vers-un-moment-d-un-sonore

Note.

Bugs restants :
- au chargement, le <cpu-controller> n'a qu'à moitié les propriétés du premier player audio, notamment titre et poster
- au rechargement, seul le premier <cpu-audio> est pris en compte pour la reprise de lecture
- sur Chrome, une erreur media n'est pas de suite remontée dans son <cpu-audio>. Il faut cliquer dessus pour qu'il aie effectiement lieu


Fonctions retirées :
- playlist offline
- i18n

Fonctions à ajouter :
- a girl has no name : un (sans titre) devrait être en italiques
- ajouter des tests TDD/BDD  ... via une page de tests ?
- mode lecture auto de la playlist paramétrable (API au niveau du DOM)
- affichage de la playlist au niveau du player global
- regrouper les fonctions en dehors du niveau de l'élément (en sub genre domobject.CPU.fx())
- native chapters via <tracks>
- support des multimedia keys
- <cpu-audio> caché, pour playlist de <cpu-controller> (si son <audio controls> est caché par défaut ?)
- ajout dynamique d'un <cpu-audio>
- suppression dynamique d'un <cpu-audio>

-->

<style>
	/* Global default style, usign var. Integrators may override them */
	:root {
		--cpu-height : 64px;
		--cpu-font-family : Lato, "Open Sans", "Segoe UI", Frutiger, "Frutiger Linotype", "Dejavu Sans", "Helvetica Neue", Arial, sans-serif;
		--cpu-font-size : 15px;
		--cpu-background : #555;
		--cpu-color : #ccc;
		--cpu-link-color : #aaf;
		--cpu-playing-background : #444;
		--cpu-playing-color : #ddd;
		--cpu-playing-link-color : #bbf;
		--cpu-error-background : #a00 ;
		--cpu-error-color : #ff7 ;
		--cpu-popup-background : #aaa;
		--cpu-popup-color : #333;

		/** TODO */
		--poster-fallback : '//dascritch.net/themes/DSN13/img/entete1.svg';
	}

	@media screen and (max-width: 640px) {
		:root {
			--cpu-font-size : 13px;
			--cpu-height : 32px;
		}
	}
</style>

<template>
<style>

.cpu-audio {
	font-family : var(--cpu-font-family);
	font-size : var(--cpu-font-size);
}

.cpu-audio, * {
	line-height : 1.2;
	border : none;
	padding : 0;
	margin : 0;
	transition : none;
	moz-user-select: none;
	ms-user-select: none;
	webkit-user-select: none;
	user-select: none;
}

.cpu-audio {
	display : flex;
	overflow : hidden;
	background : var(--cpu-background);
	color : var(--cpu-color);
	height : var(--cpu-height);
}

.act-error {
	color : var(--cpu-error-color);
}

a {
	color : var(--cpu-link-color);
	border : none;
	text-decoration : none;
}
svg {
	fill : #ffffff;
	width : var(--cpu-height);
	height : var(--cpu-height);
}
a:hover {
	color : var(--cpu-background);
	background : var(--cpu-link-color);
}
a:hover svg {
	fill : var(--cpu-background);
}

.act-play {
	background : var(--cpu-playing-background);
	color : var(--cpu-playing-color);
}

.act-play a {
	color : var(--cpu-playing-link-color);
}

.act-play a:hover {
	color : var(--cpu-playing-background);
	background : var(--cpu-playing-link-color);
}
.act-play a:hover svg {
	fill : var(--cpu-playing-background);
}

.show-error {
	background : var(--cpu-error-background);
	color : var(--cpu-error-color);
}

.pageerror {
	padding: 0px 4px;
    align-self: center;
}

.control,
.actions,
.back {
	flex : 0 0 var(--cpu-height);
	width : var(--cpu-height);
	max-height : var(--cpu-height);
	height : 100%;
	text-align : center;
	vertical-align : middle;
}
.actions,
.back {
	cursor : pointer;
}

.loading, .play, .pause,
.show-main .pageshare, .show-main .pageerror,
.show-share .pagemain, .show-share .pageerror,
.show-error .pagemain, .show-error .pageshare , .show-error .poster {
	display : none;
}

.act-loading .loading,
.act-play .play,
.act-pause .pause {
	display : block;
}

.show-share .pageshare,
.show-main .pagemain,
.share {
	flex : 1 1 100%;
	display : flex;
	align-items: center;
}

.act-loading .loading circle:nth-child(1) {
	  animation: pulse0 2s infinite;
}

.act-loading .loading circle:nth-child(2) {
	  animation: pulse1 2s infinite;
}

.act-loading .loading circle:nth-child(3) {
	  animation: pulse2 2s infinite;
}

@keyframes pulse0 {
	0% {
		opacity : 1;
	}
	50% {
		opacity : 0;
	}
	100% {
		opacity : 1;
	}
}

@keyframes pulse1 {
	0% {
		opacity : 0.75;
	}
	12% {
		opacity : 1;
	}
	62% {
		opacity : 0;
	}
	100% {
		opacity : 0.75;
	}
}

@keyframes pulse2 {
	0% {
		opacity : 0.5;
	}
	25% {
		opacity : 1;
	}
	75% {
		opacity : 0;
	}
	100% {
		opacity : 0.5;
	}
}

@keyframes pulse3 {
	0% {
		opacity : 0.25;
	}
	37% {
		opacity : 1;
	}
	87% {
		opacity : 0;
	}
	100% {
		opacity : 0.5;
	}
}

.cover {
	width : var(--cpu-height);
 }

.poster {
	width : var(--cpu-height);
	height : var(--cpu-height);
	object-fit: contain;
}

.loading svg, .play svg, .pause svg, .actions svg {
	vertical-align : middle;
	max-width : 100%;
	max-height : 100%;
}
.titleline {
	display : flex;
}
.about, .title {
	flex : 1 1 100%;
	position : relative;
}
.title a {
	display : block;
	text-overflow : ellipsis;
	max-height: 48px;
	overflow: hidden;

}
.elapse {
	flex : 1 0 170px;
	text-align : right;
}
.time {
	background : black;
	width : 100%;
	height : 10px;
	display : block;
	border-radius : 4px;
	position : relative;
	cursor:none;
}
.loadingline,
.elapsedline {
	background : white;
	height : 10px ;
	display : block ;
	position : absolute;
	left : 0;
	border-radius : 4px;
	pointer-events : none;
}
.elapsedline {
	z-index : 2;
}

.act-loading .loadingline {
	background : grey;
}

.share {
	text-align : center;
}

.share a {
	height : var(--cpu-height);
}

.share a, .share div {
	flex : 1 0;
	color : white;
	text-decoration : none;
	overflow : hidden;
	text-overflow : clip;
}
.share svg {
	vertical-align : middle;
	width : 32px;
	height : 32px;
}
.twitter {
	background : #4DB5F4
}
.facebook {
	background : #5974CC
}
.email {
	background : #CC0000
}
.link {
	background : #77F
}


.popup {
	position: absolute;
	transform: translate(-25px, -19px);
	z-index : 127;
	min-width : 50px;
	font-size : 11px;
	text-align : center;
	padding : 2px;
	border-radius: 4px;
	box-shadow: black 2px 2px;
	background : var(--cpu-popup-background);
	color : var(--cpu-popup-color);
	opacity : 0;
	pointer-events : none;
	/* absolute pos, need to repeat it →  https://developer.mozilla.org/en-US/docs/Web/CSS/user-select */
	moz-user-select: none;
	ms-user-select: none;
	webkit-user-select: none;
	user-select: none;
} 
.popup:before {
	content:"";
	position: absolute;
	left: 20px;
	bottom: -8px;
	height : 0;
	width: 0;
	border-top: 8px solid var(--cpu-popup-background);
	border-left: 4px solid transparent;
	border-right: 4px solid transparent;
	pointer-events : none;
} 

@media screen and (max-width: 640px) {

	.nosmall {
		display : none;
	}
	.title a {
		max-height : 16px;
	}

	.elapse {
		flex : 1 0 80px;
		max-height : 16px;
	}

	.time,
	.loadingline,
	.elapsedline {
		height : 8px ;
	}
}
@media screen and (max-width: 319px) {
	.elapse {
		display : none;
	}
}

@media print {
	.cpu-audio {
		display : none;
	}
}


</style>

<div class="cpu-audio">
	<img class="poster nosmall" src="" alt="" />
	<div class="pageerror">
	</div>
	<div class="pagemain">
		<div class="control">
			<div class="loading" title="Chargement en cours">
				<svg viewBox="0 0 32 32">
					<circle cx="6" cy="22" r="4" fill="#777777" />
					<circle cx="16" cy="22" r="4" fill="#777777" />
					<circle cx="26" cy="22" r="4" fill="#777777" />
				</svg>
			</div>
			<a class="play" title="Lecture">
				<svg viewBox="0 0 32 32">
					<path d="M 6,6 12.667,6 12.667,26 6,26 z" />
					<path d="M 19.333,6 26,6 26,26 19.333,26 z" />
				</svg>
			</a>
			<a class="pause" title="Pause">
				<svg viewBox="0 0 32 32">
					<path d="M 6,6 6,26 26,16 z" />
				</svg>
			</a>
		</div>
		<div class="about">
			<div class="titleline">
				<div class="title"><a href="#" class="canonical"></a></div>
				<a class="elapse">…</a>
			</div>
			<div class="line">
				<div class="time">
					<div class="loadingline"></div>
					<div class="elapsedline"></div>
					<time class="popup">--:--</time>
				</div>
			</div>
		</div>
		<a class="actions">
			<svg viewBox="0 0 32 32">
				<circle cx="12" cy="10" r="4" /><circle cx="12" cy="22" r="4" /><circle cx="23" cy="16" r="4" /><polygon points="12,8 24,14 24,18 12,12"/><polygon points="12,20 24,14 24,18 12,24"/>
			</svg>
		</a>
	</div>
	<div class="pageshare">
		<div class="share">
			<a href="#" target="social" class="twitter nosmall" title="Partager sur Twitter">
				<svg viewBox="0 0 32 32">
					<path d="M 25.941,9.885 C 25.221,10.205 24.448,10.422 23.637,10.520 24.465,10.020 25.101,9.230 25.401,8.288 24.626,8.750 23.768,9.086 22.854,9.267 22.122,8.483 21.080,7.993 19.926,7.993 c -2.215,0 -4.011,1.806 -4.011,4.034 0,0.316 0.035,0.623 0.103,0.919 -3.333,-0.168 -6.288,-1.774 -8.267,-4.215 -0.345,0.596 -0.542,1.289 -0.542,2.028 0,1.399 0.708,2.634 1.784,3.358 -0.657,-0.020 -1.276,-0.202 -1.816,-0.504 -3.98e-4,0.016 -3.98e-4,0.033 -3.98e-4,0.050 0,1.954 1.382,3.585 3.217,3.955 -0.336,0.092 -0.690,0.141 -1.056,0.141 -0.258,0 -0.509,-0.025 -0.754,-0.072 0.510,1.602 1.991,2.769 3.746,2.801 -1.372,1.082 -3.102,1.726 -4.981,1.726 -0.323,0 -0.642,-0.019 -0.956,-0.056 1.775,1.144 3.883,1.812 6.148,1.812 7.377,0 11.411,-6.147 11.411,-11.478 0,-0.174 -0.004,-0.348 -0.011,-0.522 0.783,-0.569 1.463,-1.279 2.001,-2.088 z" />
				</svg>
				<span>Partager sur Twitter</span>
			</a>
			<a href="#" target="social" class="facebook nosmall" title="Partager sur Facebook">
				<svg viewBox="0 0 32 32">
					<path d="m 21.117,16.002 -3.728,0 0,10.027 -4.297,0 0,-10.027 -2.070,0 0,-3.280 2.070,0 0,-2.130 c 0,-2.894 1.248,-4.616 4.652,-4.616 l 3.922,0 0,3.549 -3.203,0 c -0.950,-0.001 -1.068,0.495 -1.068,1.421 l -0.005,1.775 4.297,0 -0.568,3.280 0,2.34e-4 z" />
				</svg>
				<span>Partager sur Facebook</span>
			</a>
			<a href="#" target="social" class="email" title="Partager par e-mail">
				<svg viewBox="0 0 32 32">
					<path d="m 8.030,8.998 15.920,0 c 0.284,0 0.559,0.053 0.812,0.155 l -8.773,9.025 -8.773,-9.026 c 0.253,-0.101 0.528,-0.155 0.812,-0.155 z m -1.990,12.284 0,-10.529 c 0,-0.036 0.002,-0.073 0.004,-0.109 l 5.835,6.003 -5.771,5.089 c -0.045,-0.146 -0.068,-0.298 -0.069,-0.453 z m 17.910,1.754 -15.920,0 c -0.175,0 -0.348,-0.020 -0.514,-0.060 l 5.662,-4.993 2.811,2.892 2.811,-2.892 5.662,4.993 c -0.165,0.039 -0.338,0.060 -0.514,0.060 z m 1.990,-1.754 c 0,0.155 -0.023,0.307 -0.068,0.453 l -5.771,-5.089 5.835,-6.003 c 0.002,0.036 0.004,0.073 0.004,0.109 z" />
				</svg>
				<span>Partager par e-mail</span>
			</a>
			<a href="#" target="social" class="link" title="Télécharger">
				<svg viewBox="0 0 32 32">
					<path d="M 6,6 26,6 16,26 z" /><rect x="6" y="22" width="20" height="4" />
				</svg>
				<span>Télécharger</span></a>
			<a class="back" title="Annuler">Annuler</a>
		</div>
	</div>
</div>
</template>

<script>
(function(){

'use strict';

var thisDoc =  (document._currentScript || document.currentScript).ownerDocument;
var template, shadow_element;

var twitter_via = 'dascritch';
const cpu_i18n = {
	'untitled' : '(sans titre)',
	'cover' : 'pochette',
	'more' : 'Partager',
	'twitter' : 'Partager sur Twitter',
	'facebook' : 'Partager sur Facebook',
	'e-mail' : 'Partager par e-mail',
	'download' : 'Télécharger',
	'back' : 'Annuler',

	'media_err_aborted' : 'Vous avez annulé la lecture.',
	'media_err_network' : 'Une erreur réseau a causé l\'interruption du téléchargement.',
	'media_err_decode' : 'La lecture du sonore a été annulée suite à des problèmes de corruption ou de fonctionnalités non supportés par votre navigateur.',
	'media_err_src_not_supported' : 'Le sonore n\'a pu être chargé, soit à cause de sourcis sur le serveur, le réseau ou parce que le format n\'est pas supporté.',
	'media_err_unknow' : 'Erreur due à une raison inconnue'
};

function onDebug(callback_fx) {
	// this is needed for testing, as we now run in async tests
	if (typeof callback_fx === 'function') {
		callback_fx();
	}
}

function querySelector_apply(selector, callback, subtree) {
	subtree = subtree === undefined ? document : subtree;
	// explication de cette construction : https://coderwall.com/p/jcmzxw
	[].forEach.call(subtree.querySelectorAll(selector), callback);
}

const convert = {
	_units : {
		'd' : 86400,
		'h' : 3600,
		'm' : 60,
		's' : 1
	},

	TimeInSeconds : function(givenTime) {
		var seconds = 0;
		if (/^\d+$/.test(givenTime)) {
			seconds = Number(givenTime);
		} else {
			seconds = (givenTime.indexOf(':') === -1) ? this.SubunitTimeInSeconds(givenTime) : this.ColonTimeInSeconds(givenTime) ;
		}
		return seconds;
	},
	SubunitTimeInSeconds : function(givenTime) {
		var seconds = 0;
		for(var key in convert._units) {
			if ( (convert._units.hasOwnProperty(key)) && (givenTime.indexOf(key) !== -1) ) {
				var atoms = givenTime.split(key);
				seconds += Number(atoms[0].replace(/\D*/g,'' )) * convert._units[key];
				givenTime = atoms[1];
			}
		}
		return seconds;
	},
	ColonTimeInSeconds : function(givenTime) {
		var seconds = 0;
		var atoms = givenTime.split(':');
		var convert = [1, 60, 3600, 86400];
		for (var pos = 0 ; pos < atoms.length ; pos++ ) {
			seconds += Number(atoms[pos]) * convert[((atoms.length-1) - pos)];
		}
		return seconds;
	},
	SecondsInTime : function(givenSeconds) {
		var converted = '';
		var inned = false;
		for(var key in convert._units) {
			if (convert._units.hasOwnProperty(key)) {
				var multiply = convert._units[key];
				if ((givenSeconds >= multiply) || (inned)) {
					inned = true;
					var digits = Math.floor(givenSeconds / multiply);
					converted += digits + key;
					givenSeconds -= digits * multiply;
				}
			}
		}
		if (converted === '') {
			converted = '0s';
		}
		return converted;
	},
}

const trigger = {

	hashOrder : function(hashcode,callback_fx){
		let at_start = true;
		if (typeof hashcode !== 'string') {
			at_start = 'at_start' in hashcode;
			hashcode = location.hash.substr(1);
		}
		let hash = '';
		let timecode = '';
		let segments = hashcode.split('&');
		let autoplay = false;

		for (let _id in segments) {
			let parameter = segments[_id];
			if (parameter.indexOf('=') === -1) {
				// should reference to the ID of the element
				hash = parameter;
			} else {
				// should be a key=value parameter
				let atoms = parameter.split('=');
				let p_key = atoms[0];
				let p_value = atoms[1];
				switch (p_key) {
					case 't':
						// is a time index
						timecode = p_value;
						// we make autoplay at requested timecode, simplier of the user
						autoplay = true;
						break;
					case 'autoplay':
						// is a card from a social network, run now
						if (p_value='1') {
							autoplay = true;
						}
						break;
					case 'auto_play':
						// is a card from a social network, run now
						if (p_value='true') {
							autoplay = true;
						}
						break;
				}

			}
		}

		if ((timecode === '') || ((at_start) && (!autoplay))) {
			// this is a normal anchor call. Go back to normal behaviour
			onDebug(callback_fx);
			return false;
		}
		CPU_Audio.jumpIdAt(hash,timecode,callback_fx);
		// scroll to the audio element. Should be reworked
		// window.location.hash = `#${hash}`;
		return true;
	},
	hover : function(event) {
		let container = CPU_Audio.find_container(event.target);

		let target_rect = event.target.getClientRects()[0];
		let relLeft = target_rect.left;
		let ratio = (event.clientX - relLeft) / event.target.clientWidth;
		let seeked_time = ratio * container.audiotag.duration;
		container.show_thobber_at(seeked_time);
	},
	out : function(event) {
		let container = CPU_Audio.find_container(event.target);
		container.hide_throbber();
	},

	throbble : function(event) {
		let at = 0;
		let container = CPU_Audio.find_container(event.target);
		let audiotag = container.audiotag;
		if (event.at !== undefined) {
			at = event.at;
		} else {
			// normal usage
			let relLeft = event.target.getClientRects()[0].left;
			let ratio = (event.clientX - relLeft) / event.target.clientWidth;
			at = ratio * audiotag.duration;
		}
		CPU_Audio.seekElementAt(audiotag, at);
		trigger.play(event);
	},
	pause : function(event, audiotag) {
		if (audiotag === undefined) {
			audiotag = CPU_Audio.find_container(event.target).audiotag;
		}
		audiotag.pause();
		CPU_Audio.current_audiotag_playing = null;
		window.localStorage.removeItem(audiotag.currentSrc);
	},
	play : function(event, audiotag) {
		if (audiotag === undefined) {
			audiotag = CPU_Audio.find_container(event.target).audiotag;
		}
		if ( (CPU_Audio.only_play_one_audiotag) && (CPU_Audio.current_audiotag_playing) ) {
			trigger.pause(undefined, CPU_Audio.current_audiotag_playing);
		}

		CPU_Audio.current_audiotag_playing = audiotag;
		if (CPU_Audio.global_controller) {
			CPU_Audio.global_controller.attach_audiotag_to_controller(CPU_Audio.current_audiotag_playing);
			CPU_Audio.global_controller.show_main();
		}
		audiotag.play();
	},
	key : function(event) {
		let container = event.target;

		function seek_relative(seconds) {
			event.at = container.audiotag.currentTime + seconds;
			container.show_thobber_at(container, event.at);
			trigger.throbble(event);
			container.hide_throbber_later();
		}

		switch (event.keyCode) {
			// can't use enter : standard usage
			case 27 : // esc
				CPU_Audio.seekElementAt(container.audiotag, 0);
				trigger.pause(undefined,container.audiotag);
				break;
			case 32 : // space
				container.audiotag.paused ?
					trigger.play(undefined,container.audiotag) :
					trigger.pause(undefined,container.audiotag);
				break;
			case 35 : // end
				CPU_Audio.seekElementAt(container.audiotag, container.audiotag.duration);
				break;
			case 36 : // home
				CPU_Audio.seekElementAt(container.audiotag, 0);
				break;
			case 37 : // ←
				seek_relative(- CPU_Audio.keymove);
				break;
			case 39 : // →
				seek_relative(+ CPU_Audio.keymove);
				break;
			default:
				return ;
		}
		event.preventDefault();
	},
	update : function(event) {
		let audiotag = event.target;
		audiotag.CPU_update();
		if (!audiotag.paused) {
			window.localStorage.setItem(audiotag.currentSrc, String(audiotag.currentTime));
		}
	},
}

function absolutize_url(url) {
	var test_element = document.createElement('a');
	test_element.href = url;
	return test_element.href;
}

function not_screen_context() {
	return !window.matchMedia("screen").matches;
}

function prevent_link_on_same_page(event) {
	if (absolutize_url(window.location.href) !== absolutize_url(event.target.href)) {
		return ;
	}
	event.preventDefault();
}

function element_prevent_link_on_same_page(element) {
	element.addEventListener('click', prevent_link_on_same_page);
}

function _isEvent(event) {
	// is this event really triggered via a native event ?
	return event.preventDefault !== undefined;
}

const CPU_Audio = {
	// global object for global controller

	keymove : 5,
	only_play_one_audiotag : true,
	current_audiotag_playing : null,
	// this one, later
	global_controller : null,
	selector_container : 'cpu-audio',
	selector_interface : '.cpu-audio',
	dynamicallyAllocatedIdPrefix : 'CPU-Audio-tag-',
	count_element : 0,

	connect_audiotag(audiotag) {
		// see https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events for list of events
		[
			'ready', 'load', 'loadeddata', 'canplay', 'abort', 
			'error', 'stalled', 'suspend', 'emptied',
			'play', 'playing', 'pause', 'suspend', 'ended',
			'durationchange',  'loadedmetadata', 'progress', 'timeupdate', 'waiting'
		].forEach( function(on){ 
			audiotag.addEventListener(on, trigger.update); 
		});

		audiotag.addEventListener('loadedmetadata', CPU_Audio.recall_stored_play);
		// those ↓ for PHRACKING SAFARI
		audiotag.addEventListener('ready', CPU_Audio.recall_stored_play);
		audiotag.addEventListener('canplay', CPU_Audio.recall_stored_play);

		// ask ASAP metadata about media
		// we have to set in HTML code preload="none" due to a very laggy behaviour in HTTP2
		// https://stackoverflow.com/questions/14479413/chrome-ignoring-audio-preload-metadata
		if (audiotag.preload === '') {
			audiotag.preload = 'metadata';
		}
		audiotag.load();
		if (this.dontHideAudioTag === false) {
			audiotag.hidden = true;
			// PHRACK SAFARI
			audiotag.removeAttribute('controls');
		}
	},

	jumpIdAt : function(hash,timecode,callback_fx) {

		function do_needle_move(event) {
			let audiotag = event.target;

			if (_isEvent(event)) {
				audiotag.removeEventListener('loadedmetadata', do_needle_move, true);
			}

			var secs = convert.TimeInSeconds(timecode);
			CPU_Audio.seekElementAt(audiotag, secs);

			if (audiotag.readyState >= audiotag.HAVE_FUTURE_DATA)  {
				do_element_play({ target : audiotag });
			} else {
				audiotag.addEventListener('canplay', do_element_play, true);
			}
			trigger.update({target : audiotag});
		}

		function do_element_play(event) {
			var tag = event.target;
			trigger.play(undefined,tag)
			if (_isEvent(event)) {
				tag.removeEventListener('canplay', do_element_play, true);
			}
			onDebug(callback_fx);
		}

		let audiotag = (hash !== '') ? document.getElementById(hash) : document.querySelector(this.selector_fallback);

		if ((audiotag === undefined) || (audiotag === null) || (audiotag.currentTime === undefined)) {
			return false;
		}

		if (audiotag.readyState < audiotag.HAVE_CURRENT_DATA ) {
			audiotag.addEventListener('loadedmetadata', do_needle_move , true);
			audiotag.load();
		} else {
			do_needle_move({target : audiotag});
		}
		trigger.update({target : audiotag});
	},

	find_container : function(child) {
		if (child.tagName ===  CPU_Audio.selector_container.toUpperCase()) {
			return child
		}
		// DOMnode.closest won't work in too old browsers
		// CF https://caniuse.com/#search=closest
		return this.find_interface(child).parentNode.host;
	},
	find_interface : function(child) {
		return child.closest(CPU_Audio.selector_interface);
	},
	seekElementAt : function (audiotag, seconds) {

		if (audiotag.fastSeek !== undefined) {
			audiotag.fastSeek(seconds);
			// Firefox doesn't see fastSeek
		} else {
			try {
				// but can set currentTime
				audiotag.currentTime = seconds;
			} catch(e) {
				// exept sometimes, so you must use standard media fragment
				audiotag.src = `${audiotag.currentSrc.split('#')[0]}#t=${seconds}`;
			}
		}

		audiotag.CPU_controller().update_loading(seconds);
	},

	recall_stored_play : function(event) {
		if (CPU_Audio.current_audiotag_playing !== null) {
			return;
		} 
		let audiotag = event.target;
		let lasttimecode = Number(window.localStorage.getItem(audiotag.currentSrc));
		// TODO and no hashed time
		if (lasttimecode > 0) {
			CPU_Audio.seekElementAt(audiotag, lasttimecode);
			trigger.play(undefined, audiotag);
		}
	}

}

// Extension on media element

HTMLAudioElement.prototype.CPU_controller = function() {
	return this.closest(CPU_Audio.selector_container);
}

HTMLAudioElement.prototype.CPU_update = function() {
	if (this.CPU_controller().update) {
		this.CPU_controller().update();
	}
	if (CPU_Audio.global_controller) {
		CPU_Audio.global_controller.update();
	}
}

// Controller without assigned audio element, i.e. global page controller
class CpuControllerElement extends HTMLElement {

	constructor() {
		// Always call super first in constructor
		super();

		if (not_screen_context()) {
			// I'm not in a screen context, as a braille surface
			// Sorry, but your browser's native controls are surely more accessible
			return ;
		}

		// self variables
		this.dontHideAudioTag = false;
		this.poster_fallback = '//dascritch.net/themes/DSN13/img/entete1.svg';
		this._elements = {};
		this.audiotag = null;

		template =  thisDoc.querySelector('template');
		shadow_element = this.attachShadow({mode: 'open'})//.appendChild(template.cloneNode(true));
		shadow_element.innerHTML = thisDoc.querySelector('template').innerHTML;
	}

	connectedCallback() {
		if (not_screen_context()) {
			return ;
		}
		this.container = shadow_element.querySelector('.cpu-audio');
		this.build_controller();
		// TODO : Event should be set on controller , with checking event.originalTarget.classlist.has()
		querySelector_apply('.canonical', element_prevent_link_on_same_page);

		if (this.audiotag === null) {
			CPU_Audio.global_controller = this;
			this.audiotag = window.document.querySelector('cpu-audio audio');
		}
		this.attach_audiotag_to_controller(this.audiotag);
		trigger.hashOrder({ at_start : true });
	}

	disconnectedCallback() {
	}

	update_act_container(act) {
		this.container.classList.remove(
			'act-loading',
			'act-pause',
			'act-play'
			);
		this.container.classList.add(`act-${act}`);
	}

	update_playbutton() {
		if (this.audiotag.readyState < this.audiotag.HAVE_CURRENT_DATA ) {
			this.update_act_container('loading');
			return;
		}

		this.update_act_container(this.audiotag.paused ? 'pause' : 'play');
	}

	update_line(type, seconds) {
		// type = 'elapsed', 'loading'
		let duration = this.audiotag.duration;
		this._elements[`${type}line`].style.width = duration === 0
												? 0
												: `${100*seconds / duration}%`;
	}

	update_buffered() {
		let end = 0;
		let buffered  = this.audiotag.buffered ;
		let segment;
		for (segment=0 ; segment++; segment < buffered.length) {
			end = buffered.end(segment)
		}
		this.update_line('elapsed', end);
	}
	update_time(event) {
		let timecode = convert.SecondsInTime(this.audiotag.currentTime);
		let link_to = absolutize_url(this.audiotag.dataset.canonical)+'#';
		link_to += this.audiotag.id ? (this.audiotag.id+'&') : '';
		link_to += 't='+timecode;

		let elapse_element = this._elements['elapse'];
		elapse_element.href = link_to;

		let total_duration = '…';
		if (!isNaN(Math.round(this.audiotag.duration))){
			total_duration = convert.SecondsInTime(Math.round(this.audiotag.duration));
		} 
		 
		elapse_element.innerHTML = `${timecode}
									<span class="nosmall"> / ${total_duration}</span>`;
		this.update_line('loading', this.audiotag.currentTime);
		this.update_buffered();
	}

	update_loading(seconds) {
		this.update_line('loading', seconds);
		this.update_act_container('loading');
	}

	update_error() {
		// NOTE : this is not working, even on non supported media type
		// Chrome logs an error « Uncaught (in promise) DOMException: Failed to load because no supported source was found. »
		// but don't update message
		if (this.audiotag.error !== null) {
			let error_message;
			let pageerror = this._elements['pageerror'];
			this.show_interface('error');
			switch (this.audiotag.error.code) {
				case this.audiotag.error.MEDIA_ERR_ABORTED:
					error_message = cpu_i18n.media_err_aborted;
					break;
				case this.audiotag.error.MEDIA_ERR_NETWORK:
					error_message = cpu_i18n.media_err_network;
					break;
				case this.audiotag.error.MEDIA_ERR_DECODE:
					error_message = cpu_i18n.media_err_decode;
					break;
				case this.audiotag.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
					error_message = cpu_i18n.media_err_src_not_supported;
					break;
				default:
					error_message = cpu_i18n.media_err_unknow;
					break;
			}
			pageerror.innerText = error_message;
			return true;
		}
		return false;
	}

	update() {
		if (!this.update_error()) {
			this.update_playbutton();
			this.update_time();
		}
	}

	show_thobber_at(seeked_time) {
		if (this.audiotag.duration < 1) {
			// do not try to show if no metadata
			return;
		}
		var phylactere = this._elements['popup'];
		var elapse_element = this._elements['line'];

		phylactere.style.opacity = 1;
		phylactere.style.left = (100 * seeked_time / this.audiotag.duration ) +'%';
		phylactere.innerHTML = convert.SecondsInTime(seeked_time);
	}
	hide_throbber() {
		var phylactere = this._elements['popup'];
		phylactere.style.opacity = 0;
	}
	hide_throbber_later() {
		var phylactere = this._elements['popup'];
		if (phylactere._hider) {
			window.clearTimeout(phylactere._hider);
		}
		phylactere._hider = window.setTimeout(this.hide_throbber, 1000);

	}

	update_links() {
		var container = this;
		function ahref(category, href) {
			container._elements[category].href = href;
		}
		function remove_hash(canonical) {
			var hash_at = canonical.indexOf('#');
			return hash_at === -1 ? canonical : canonical.substr(0,hash_at);
		}

		var canonical = this.audiotag.dataset.canonical
		var url = (canonical === undefined ? '' : remove_hash(canonical) )
					+ `#${this.audiotag.id}` 
					+ ( this.audiotag.currentTime === 0 
							? ''
							: `&t=${convert.SecondsInTime(this.audiotag.currentTime)}`
						);

		var _url = encodeURI(absolutize_url(url));
		var _title = encodeURI(this.audiotag.title);
		ahref('twitter', `https://twitter.com/share?text=${_title}&url=${_url}&via=${twitter_via}`);
		ahref('facebook', `https://www.facebook.com/sharer.php?t=${_title}&u=${_url}`);
		ahref('email', `mailto:?subject=${_title}&body=${_url}`);
		ahref('link', this.audiotag.currentSrc);
	}

	show_interface(mode) {
		this.container.classList.remove('show-main', 'show-share', 'show-error');
		this.container.classList.add('show-'+mode);
	}
	show_actions(event) {
		let container = (event !== undefined) ?
				CPU_Audio.find_container(event.target) :
				this;
		container.show_interface('share');
		container.update_links();
	}
	show_main(event) {
		let container = (event !== undefined) ?
				CPU_Audio.find_container(event.target) :
				this;
		container.show_interface('main');
	}
	element_attribute(element, key, missing) {
		return (element.attributes[key] === undefined) ? missing : element.attributes[key].value;
	}

	add_id_to_container() {
		this.id = this.id !== ''? this.id : (this.idPrefix + String(CPU_Audio.count_element++));
	}
	add_id_to_audiotag() {
		if (this.audiotag.id === '') {
			this.audiotag.id = CPU_Audio.dynamicallyAllocatedIdPrefix + String(CPU_Audio.count_element++);
		}
	}

	complete_template() {
		var canonical = this.audiotag.dataset.canonical;
		if (canonical === undefined) {
			canonical = window.location.href;
		}
		this._elements['canonical'].href = canonical;

		var title = this.audiotag.dataset.title;
		title = title === undefined ? cpu_i18n['untitled'] : title;
		this._elements['canonical'].innerText = title; 
		this._elements['canonical'].title = title;

		this._elements['poster'].src = this.audiotag.dataset.poster;
	}
	attach_audiotag_to_controller(audiotag) {
		this.audiotag = audiotag;

		this.add_id_to_audiotag()
		this.complete_template();

		// throw simplified event
		trigger.update({target : this.audiotag});
	}
	build_controller() {

		this.classList.add(this.classname);
		this.tabIndex = 0 // see http://snook.ca/archives/accessibility_and_usability/elements_focusable_with_tabindex and http://www.456bereastreet.com/archive/201302/making_elements_keyboard_focusable_and_clickable/

		// the following mess is to simplify sub element declaration and selection
		this._elements = {};
		let controller = this;
		querySelector_apply('*', function(element){
			element.classList.forEach(function(this_class) {
				if (controller._elements[this_class] === undefined) {
					controller._elements[this_class] = element;
				}
			});
		}, this.shadowRoot);

		let cliquables = {
			'pause'		: trigger.play,
			'play'		: trigger.pause,
			'time'		: trigger.throbble,
			'actions'	: this.show_actions,
			'back' 		: this.show_main,
			'poster'	: this.show_main,
		};
		for (let that in cliquables) {
			this._elements[that].addEventListener('click', cliquables[that]);
		}
		// key management
		this.addEventListener('keydown', trigger.key);
		// throbber management
		let timeline_element = this._elements['time'];
		let do_events = {
			'mouseover' : true,
			'mousemove' : true,
			'mouseout'  : false,

			'touchstart'  : true,
			// 'touchmove'   : true,
			'touchend'    : false,
			'touchcancel' : false,
		}
		for(let event_name in do_events) {
			timeline_element.addEventListener(
				event_name,
				do_events[event_name] ? trigger.hover : trigger.out);				
		}
		this.show_main();
	}

}

// Controller with assigned audio element
class CpuAudioElement extends CpuControllerElement {

	connectedCallback() {
		if (not_screen_context()) {
			return ;
		}

		this.audiotag = this.querySelector('audio');
		// copying personalized data to audio tag
		for (var key of ['title', 'poster', 'canonical']) {
			this.audiotag.dataset[key] = this.dataset[key];
		}
		super.connectedCallback();

		CPU_Audio.connect_audiotag(this.audiotag);

		CPU_Audio.recall_stored_play({target : this.audiotag});
		trigger.hashOrder({ at_start : true });
	}

}

window.customElements.define('cpu-controller', CpuControllerElement);
window.customElements.define(CPU_Audio.selector_container, CpuAudioElement);
window.addEventListener('hashchange', trigger.hashOrder, false);

})();
</script>
