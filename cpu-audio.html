<!--

Cpu-Audio, an extension to the hash system to address timecode into audio/video elements
Copyright (C) 2014-2018 Xavier "dascritch" Mouton-Dubosc

Previously TimecodeHash, then OndeMirroir Audio Tag

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

project repository : https://github.com/dascritch/ondemiroir-audio-tag
blog post : http://dascritch.net/post/2014/09/03/Timecodehash-%3A-Lier-vers-un-moment-d-un-sonore

Note. Fonctions retirées :
- i18n
-->

<style>
	/* Global default style, usign var. Integrators may override them */
	:root {
		--cpu-font-family : Lato, "Open Sans", "Segoe UI", Frutiger, "Frutiger Linotype", "Dejavu Sans", "Helvetica Neue", Arial, sans-serif;
		--cpu-font-size : 15px;
		--cpu-background : #555;
		--cpu-color : #ccc;
	}
</style>

<template>
<style>

.cpu-audio {
	font-family : var(--cpu-font-family) !important;
	font-size : var(--cpu-font-size) !important;
}

.cpu-audio, * {
	line-height : 1.2 !important;
	border : none !important;
	padding : 0 !important;
	margin : 0 !important;
	transition : none !important;
	moz-user-select: none;
	ms-user-select: none;
	webkit-user-select: none;
	user-select: none;
}

.cpu-audio {
	display : flex;
	background : var(--cpu-background);
	color : var(--cpu-color);
	height : 64px;
}

.act-error {
	color : #cc0;
}

a {
	color : #aaf;
	border : none !important;
	text-decoration : none;
}
svg {
  	fill : #ffffff;
  	width:64px;
	height : 64px;
}
a:hover {
	color : var(--cpu-background);
	background : #aaf;
}
a:hover svg {
	fill : var(--cpu-background);
}
.control,
.actions,
.back {
	flex : 0 0 64px;
	width : 64px;
	max-height : 64px;
	height : 100%;
	text-align : center;
	vertical-align : middle;
}
.actions,
.back {
	cursor : pointer;
}

.loading, .play, .pause,
.show-main .pageshare, .show-share .pagemain {
	display : none;
}

.act-loading .loading,
.act-play .play,
.act-pause .pause {
	display : block;
}

.show-share .pageshare,
.show-main .pagemain,
.share {
	flex : 1 1 100%;
	display : flex;
	align-items: center;
}

.act-loading .loading circle:nth-child(1) {
	  animation: pulse0 2s infinite;
}

.act-loading .loading circle:nth-child(2) {
	  animation: pulse1 2s infinite;
}

.act-loading .loading circle:nth-child(3) {
	  animation: pulse2 2s infinite;
}

@keyframes pulse0 {
    0% {
        opacity : 1;
    }
    50% {
        opacity : 0;
    }
    100% {
        opacity : 1;
    }
}

@keyframes pulse1 {
    0% {
        opacity : 0.75;
    }
    12% {
        opacity : 1;
    }
    62% {
        opacity : 0;
    }
    100% {
        opacity : 0.75;
    }
}

@keyframes pulse2 {
    0% {
        opacity : 0.5;
    }
    25% {
        opacity : 1;
    }
    75% {
        opacity : 0;
    }
    100% {
        opacity : 0.5;
    }
}

@keyframes pulse3 {
    0% {
        opacity : 0.25;
    }
    37% {
        opacity : 1;
    }
    87% {
        opacity : 0;
    }
    100% {
        opacity : 0.5;
    }
}

.cover {
	width : 64px;
 }

.poster {
	width : 64px;
	height : 64px;
	object-fit: contain;
}

.loading svg, .play svg, .pause svg, .actions svg {
	vertical-align : middle;
	max-width : 100%;
	max-height : 100%;
}
.titleline {
	display : flex;
}
.about, .title {
	flex : 1 1 100%;
	position : relative;
}
.title a {
    display : block;
	text-overflow : ellipsis;
	max-height: 48px;
	overflow: hidden;

}
.elapse {
	flex : 1 0 160px;
	text-align : right;
}
.time {
	background : black;
	width : 100%;
	height : 10px;
	display : block;
	border-radius : 4px;
	position : relative;
	cursor:none;
}
.loadingline,
.elapsedline {
	background : white;
	height : 10px ;
	display : block ;
	position : absolute;
	left : 0;
	border-radius : 4px;
	pointer-events : none;
}

.act-loading .loadingline {
	animation: pulse3 2s infinite;
}

.share {
	text-align : center;
}

.share a {
	height : 64px;
}

.share a, .share div {
	flex : 1 0;
	color : white;
	text-decoration : none;
	overflow : hidden;
	text-overflow : clip;
}
.share svg {
	vertical-align : middle;
  		width:32px;
		height : 32px;
}
.twitter {background : #4DB5F4}
.facebook {background : #5974CC}
.email {background : #CC0000}
.link {background : #77F}

@media screen and (max-width: 640px) {

	.cpu-audio {
		height : 32px;
		font-size : 12px;
	}

  	.nosmall {
		display : none;
  	}
  	.control,
	.actions {
		flex : 0 0 32px;
		height : 32px;
		width : 32px;
	}
	svg {
  		width:32px;
		height : 32px;
	}
	.title a {
		max-height : 16px;
	}

  	.elapse {
  		flex : 1 0 80px;
		max-height : 16px;
  	}

  	.share a {
		height : 32px;
	}
}
@media screen and (max-width: 319px) {
	.elapse {
		display : none;
	}
}

@media print {
	.cpu-audio {
		display : none;
	}
}

.popup {
	position: absolute;
	transform: translate(-25px, -15px);
	z-index : 127;
	min-width : 50px;
	font-size : 11px;
	text-align : center;
	padding : 4px;
	border-radius: 4px;
	background : var(--cpu-color);
	color : var(--cpu-background);
	opacity : 0;
	transition : opacity 1s;
	pointer-events : none;
	/* absolute pos, need to repeat it →  https://developer.mozilla.org/en-US/docs/Web/CSS/user-select */
	moz-user-select: none;
	ms-user-select: none;
	webkit-user-select: none;
	user-select: none;
} 

.popup:before {
	content:"";
	position: absolute;
	left: 20px;
	bottom: -8px;
	height : 0;
	width: 0;
	border-top: 8px solid var(--cpu-background);
	border-left: 4px solid transparent;
	border-right: 4px solid transparent;
	pointer-events : none;
} 

</style>

<div class="cpu-audio">
	<img class="poster nosmall" src="" alt="" />
	<div class="pagemain">
		<div class="control">
			<div class="loading" title="Chargement en cours">
				<svg viewBox="0 0 32 32">
					<circle cx="6" cy="22" r="4" fill="#777777" />
					<circle cx="16" cy="22" r="4" fill="#777777" />
					<circle cx="26" cy="22" r="4" fill="#777777" />
				</svg>
			</div>
			<a class="play" title="Lecture">
				<svg viewBox="0 0 32 32">
					<path d="M 6,6 12.667,6 12.667,26 6,26 z" />
					<path d="M 19.333,6 26,6 26,26 19.333,26 z" />
				</svg>
			</a>
			<a class="pause" title="Pause">
				<svg viewBox="0 0 32 32">
					<path d="M 6,6 6,26 26,16 z" />
				</svg>
			</a>
		</div>
		<div class="about">
			<div class="titleline">
				<div class="title"><a href="#" class="canonical"></a></div>
				<a class="elapse">…</a>
			</div>
			<div class="line">
				<div class="time">
					<div class="loadingline"></div>
					<div class="elapsedline"></div>
					<time class="popup">--:--</time>
				</div>
			</div>
		</div>
		<a class="actions">
			<svg viewBox="0 0 32 32">
				<circle cx="12" cy="10" r="4" /><circle cx="12" cy="22" r="4" /><circle cx="23" cy="16" r="4" /><polygon points="12,8 24,14 24,18 12,12"/><polygon points="12,20 24,14 24,18 12,24"/>
			</svg>
		</a>
	</div>
	<div class="pageshare">
		<div class="share">
			<a href="#" target="social" class="twitter nosmall" title="Partager sur Twitter">
				<svg viewBox="0 0 32 32">
					<path d="M 25.941,9.885 C 25.221,10.205 24.448,10.422 23.637,10.520 24.465,10.020 25.101,9.230 25.401,8.288 24.626,8.750 23.768,9.086 22.854,9.267 22.122,8.483 21.080,7.993 19.926,7.993 c -2.215,0 -4.011,1.806 -4.011,4.034 0,0.316 0.035,0.623 0.103,0.919 -3.333,-0.168 -6.288,-1.774 -8.267,-4.215 -0.345,0.596 -0.542,1.289 -0.542,2.028 0,1.399 0.708,2.634 1.784,3.358 -0.657,-0.020 -1.276,-0.202 -1.816,-0.504 -3.98e-4,0.016 -3.98e-4,0.033 -3.98e-4,0.050 0,1.954 1.382,3.585 3.217,3.955 -0.336,0.092 -0.690,0.141 -1.056,0.141 -0.258,0 -0.509,-0.025 -0.754,-0.072 0.510,1.602 1.991,2.769 3.746,2.801 -1.372,1.082 -3.102,1.726 -4.981,1.726 -0.323,0 -0.642,-0.019 -0.956,-0.056 1.775,1.144 3.883,1.812 6.148,1.812 7.377,0 11.411,-6.147 11.411,-11.478 0,-0.174 -0.004,-0.348 -0.011,-0.522 0.783,-0.569 1.463,-1.279 2.001,-2.088 z" />
				</svg>
				<span>Partager sur Twitter</span>
			</a>
			<a href="#" target="social" class="facebook nosmall" title="Partager sur Facebook">
				<svg viewBox="0 0 32 32">
					<path d="m 21.117,16.002 -3.728,0 0,10.027 -4.297,0 0,-10.027 -2.070,0 0,-3.280 2.070,0 0,-2.130 c 0,-2.894 1.248,-4.616 4.652,-4.616 l 3.922,0 0,3.549 -3.203,0 c -0.950,-0.001 -1.068,0.495 -1.068,1.421 l -0.005,1.775 4.297,0 -0.568,3.280 0,2.34e-4 z" />
				</svg>
				<span>Partager sur Facebook</span>
			</a>
			<a href="#" target="social" class="email" title="Partager par e-mail">
				<svg viewBox="0 0 32 32">
					<path d="m 8.030,8.998 15.920,0 c 0.284,0 0.559,0.053 0.812,0.155 l -8.773,9.025 -8.773,-9.026 c 0.253,-0.101 0.528,-0.155 0.812,-0.155 z m -1.990,12.284 0,-10.529 c 0,-0.036 0.002,-0.073 0.004,-0.109 l 5.835,6.003 -5.771,5.089 c -0.045,-0.146 -0.068,-0.298 -0.069,-0.453 z m 17.910,1.754 -15.920,0 c -0.175,0 -0.348,-0.020 -0.514,-0.060 l 5.662,-4.993 2.811,2.892 2.811,-2.892 5.662,4.993 c -0.165,0.039 -0.338,0.060 -0.514,0.060 z m 1.990,-1.754 c 0,0.155 -0.023,0.307 -0.068,0.453 l -5.771,-5.089 5.835,-6.003 c 0.002,0.036 0.004,0.073 0.004,0.109 z" />
				</svg>
				<span>Partager par e-mail</span>
			</a>
			<a href="#" target="social" class="link" title="Télécharger">
				<svg viewBox="0 0 32 32">
					<path d="M 6,6 26,6 16,26 z" /><rect x="6" y="22" width="20" height="4" />
				</svg>
				<span>Télécharger</span></a>
			<a class="back" title="Annuler">Annuler</a>
		</div>
	</div>
</div>
</template>

<script>
'use strict';

// WATCH OUT ! You should NOT use this script in a unsecure domain name
if (document.domain !== '') {
	document.domain = document.domain.replace(/^(.*\.)?(\w+\.\w+)$/,'$2');
}


(function(){


var thisDoc =  (document._currentScript || document.currentScript).ownerDocument;
var template, shadow_element;

var twitter_via = 'dascritch';
const cpu_i18n = {
	'untitled' : '(sans titre)',
	'cover' : 'pochette',
	'more' : 'Partager',
	'twitter' : 'Partager sur Twitter',
	'facebook' : 'Partager sur Facebook',
	'e-mail' : 'Partager par e-mail',
	'download' : 'Télécharger',
	'back' : 'Annuler',

	'media_err_aborted' : 'Vous avez annulé la lecture.',
	'media_err_network' : 'Une erreur réseau a causé l\'interruption du téléchargement.',
	'media_err_decode' : 'La lecture du sonore a été annulée suite à des problèmes de corruption ou de fonctionnalités non supportés par votre navigateur.',
	'media_err_src_not_supported' : 'Le sonore n\'a pu être chargé, soit à cause de sourcis sur le serveur, le réseau ou parce que le format n\'est pas supporté.',
	'media_err_unknow' : 'Erreur due à une raison inconnue'
};

function onDebug(callback_fx) {
	// this is needed for testing, as we now run in async tests
	if (typeof callback_fx === 'function') {
		callback_fx();
	}
}

function querySelector_apply(selector, callback, subtree) {
	subtree = subtree === undefined ? document : subtree;
	// explication de cette construction : https://coderwall.com/p/jcmzxw
	[].forEach.call(subtree.querySelectorAll(selector), callback);
}

const convert = {
	_units : {
		'd' : 86400,
		'h' : 3600,
		'm' : 60,
		's' : 1
	},

	TimeInSeconds : function(givenTime) {
		var seconds = 0;
		if (/^\d+$/.test(givenTime)) {
			seconds = Number(givenTime);
		} else {
			seconds = (givenTime.indexOf(':') === -1) ? this.SubunitTimeInSeconds(givenTime) : this.ColonTimeInSeconds(givenTime) ;
		}
		return seconds;
	},
	SubunitTimeInSeconds : function(givenTime) {
		var seconds = 0;
		for(var key in convert._units) {
			if ( (convert._units.hasOwnProperty(key)) && (givenTime.indexOf(key) !== -1) ) {
				var atoms = givenTime.split(key);
				seconds += Number(atoms[0].replace(/\D*/g,'' )) * convert._units[key];
				givenTime = atoms[1];
			}
		}
		return seconds;
	},
	ColonTimeInSeconds : function(givenTime) {
		var seconds = 0;
		var atoms = givenTime.split(':');
		var convert = [1, 60, 3600, 86400];
		for (var pos = 0 ; pos < atoms.length ; pos++ ) {
			seconds += Number(atoms[pos]) * convert[((atoms.length-1) - pos)];
		}
		return seconds;
	},
	SecondsInTime : function(givenSeconds) {
		var converted = '';
		var inned = false;
		for(var key in convert._units) {
			if (convert._units.hasOwnProperty(key)) {
				var multiply = convert._units[key];
				if ((givenSeconds >= multiply) || (inned)) {
					inned = true;
					var digits = Math.floor(givenSeconds / multiply);
					converted += digits + key;
					givenSeconds -= digits * multiply;
				}
			}
		}
		if (converted === '') {
			converted = '0s';
		}
		return converted;
	},
}

const trigger = {

	hashOrder : function(hashcode,callback_fx){
		let at_start = true;
		if (typeof hashcode !== 'string') {
			at_start = 'at_start' in hashcode;
			hashcode = location.hash.substr(1);
		}
		let hash = '';
		let timecode = '';
		let segments = hashcode.split('&');
		let autoplay = false;

		for (let _id in segments) {
			let parameter = segments[_id];
			if (parameter.indexOf('=') === -1) {
				// should reference to the ID of the element
				hash = parameter;
			} else {
				// should be a key=value parameter
				let atoms = parameter.split('=');
				let p_key = atoms[0];
				let p_value = atoms[1];
				switch (p_key) {
					case 't':
						// is a time index
						timecode = p_value;
						// we make autoplay at requested timecode, simplier of the user
						autoplay = true;
						break;
					case 'autoplay':
						// is a card from a social network, run now
						if (p_value='1') {
							autoplay = true;
						}
						break;
					case 'auto_play':
						// is a card from a social network, run now
						if (p_value='true') {
							autoplay = true;
						}
						break;
				}

			}
		}

		if ((timecode === '') || ((at_start) && (!autoplay))) {
			// this is a normal anchor call. Go back to normal behaviour
			onDebug(callback_fx);
			return false;
		}
		self.jumpIdAt(hash,timecode,callback_fx);
		// scroll to the audio element. Should be reworked
		document.location.hash = `#${hash}`;
		return true;
	},
	hover : function(event) {
		let container = CPU_Audio.find_container(event.originalTarget);

		let target_rect = event.target.getClientRects()[0];
		let relLeft = target_rect.left;
		let ratio = (event.clientX - relLeft) / event.target.clientWidth;
		let seeked_time = ratio * container.audiotag.duration;
		container.show_thobber_at(seeked_time);
	},
	out : function(event) {
		self.hide_throbber(self.container);
	},

	throbble : function(event) {
		//var container = self.find_container(event.target);
		let at = 0;
		if (event.at !== undefined) {
			at = event.at;
		} else {
			// normal usage
			let relLeft = event.target.getClientRects()[0].left;
			let ratio = (event.clientX - relLeft) / event.target.clientWidth;
			at = ratio * self.audiotag.duration;
		}
		CPU_Audio.seekElementAt(self.audiotag, at);
		trigger.play(event);
	},
	pause : function(event, audiotag) {
		self.audiotag.pause();
		self.current_audiotag_playing = null;
		localStorage.removeItem(self.audiotag.currentSrc);
	},
	play : function(event, audiotag) {
		if (audiotag === undefined) {
			audiotag = self.audiotag;
		}
		if ( (self.only_play_one_audiotag) && (self.current_audiotag_playing) ) {
			trigger.pause(undefined, document.getElementById(self.current_audiotag_playing))
		}
		self.current_audiotag_playing = audiotag.id;
		self.audiotag.play();
	},
	key : function(event) {
		let container = CPU_Audio.find_container(event.target);

		function seek_relative(seconds) {
			event.at = self.audiotag.currentTime + seconds;
			container.show_thobber_at(self.container, event.at);
			trigger.throbble(event);
			self.hide_throbber_later(self.container);
		}

		

		switch (event.keyCode) {
			// can't use enter : standard usage
			case 27 : // esc
				CPU_Audio.seekElementAt(container.audiotag, 0);
				self.audiotag.pause();
				break;
			case 32 : // space
				self.audiotag.paused ? self.audiotag.play() : self.audiotag.pause();
				break;
			case 35 : // end
				CPU_Audio.seekElementAt(self.audiotag, self.audiotag.duration);
				break;
			case 36 : // home
				CPU_Audio.seekElementAt(self.audiotag, 0);
				break;
			case 37 : // ←
				seek_relative(- CPU_Audio.keymove);
				break;
			case 39 : // →
				seek_relative(+ CPU_Audio.keymove);
				break;
		}
	},
	update : function(event) {
		let audiotag = event.target;
		// CPU_Audio.find_container(audiotag).update();
		// et éventuellement, le controlleur global de page
		// CPU_Audio.global_controller.update();
		if (!audiotag.paused) {
			localStorage.setItem(audiotag.currentSrc, String(audiotag.currentTime));
		}
	},
}

function absolutize_url(url) {
	var test_element = document.createElement('a');
	test_element.href = url;
	return test_element.href;
}

function not_screen_context() {
	return !window.matchMedia("screen").matches;
}

function prevent_link_on_same_page(event) {
	if (absolutize_url(document.location.href) !== absolutize_url(event.target.href)) {
		return ;
	}
	event.preventDefault();
}

function element_prevent_link_on_same_page(element) {
	element.addEventListener('click', prevent_link_on_same_page);
}


const CPU_Audio = {
	// global object for global controller

	keymove : 5,
	only_play_one_audiotag : true,
	current_audiotag_playing : null,
	// this one, later
	global_controller : null,
	selector_container : 'cpu-audio',
	selector_interface : '.cpu-audio',
	dynamicallyAllocatedIdPrefix : 'CPU-Audio-tag-',
	count_element : 0,

	do_needle_move : function(event) {

		if (_isEvent(event)) {
			self.audiotag.removeEventListener('loadedmetadata', CPU_Audio.do_needle_move, true);
		}

		var secs = convert.TimeInSeconds(timecode);
		CPU_Audio.seekElementAt(self.audiotag, secs);

		if (self.audiotag.readyState >= audiotag.HAVE_FUTURE_DATA)  {
			do_element_play({ target : self.audiotag });
		} else {
			self.audiotag.addEventListener('canplay', do_element_play, true);
		}
		trigger.update({target : self.audiotag});
	},

	jumpIdAt : function(hash,timecode,callback_fx) {
		function _isEvent(event) {
			// is this event really triggered via a native event ?
			return event.preventDefault !== undefined;
		}

		function do_element_play(event) {
			var tag = event.target;
			tag.play();
			if (_isEvent(event)) {
				tag.removeEventListener('canplay', do_element_play, true);
			}
			onDebug(callback_fx);
		}

		let audiotag = (hash !== '') ? document.getElementById(hash) : document.querySelector(this.selector_fallback);

		if ((audiotag === undefined) || (audiotag === null) || (audiotag.currentTime === undefined)) {
			return false;
		}

		if (audiotag.readyState < audiotag.HAVE_CURRENT_DATA ) {
			audiotag.addEventListener('loadedmetadata', CPU_Audio.do_needle_move , true);
			audiotag.load();
		} else {
			CPU_Audio.do_needle_move({});
		}
		trigger.update({target : audiotag});
	},

	find_container : function(child) {
		// DOMnode.closest won't work in too old browsers
		// CF https://caniuse.com/#search=closest
		return child.closest(CPU_Audio.selector_container);
	},
	find_interface : function(child) {
		return child.closest(CPU_Audio.selector_interface);
	},
	seekElementAt : function (audiotag, seconds) {
		if (audiotag.fastSeek !== undefined) {
			audiotag.fastSeek(seconds);
			// Firefox doesn't see fastSeek
		} else {
			try {
				// but can set currentTime
				audiotag.currentTime = seconds;
			} catch(e) {
				// exept sometimes, so you must use standard media fragment
				audiotag.src = `${audiotag.currentSrc.split('#')[0]}#t=${seconds}`;
			}
		}

		CPU_Audio.find_container(audiotag).update_loading();
	},

	recall_stored_play : function(event) {
		if (CPU_Audio.current_audiotag_playing !== null) {
			return;
		} 
		let audiotag = event.target;
		let lasttimecode = Number(localStorage.getItem(audiotag.currentSrc));
		// TODO and no hashed time
		if (lasttimecode > 0) {
			self.seekElementAt(audiotag, lasttimecode);
			trigger.play(undefined, audiotag);
		}
	}

}

// Extension on media element

// Controller without assigned audio element, i.e. global page controller
class CpuControllerElement extends HTMLElement {
}

// Controller with assigned audio element
class CpuAudioElement extends CpuControllerElement {

	constructor() {
		// Always call super first in constructor
		super();

		if (not_screen_context()) {
			// I'm not in a screen context, as a braille surface
			// Sorry, but your browser's native controls are surely more accessible
			return ;
		}

		// self variables

		this.selector_fallback = 'audio[data-ondeplayer]';
		
		this.dontHideAudioTag = false;
		this.poster_fallback = '//dascritch.net/themes/DSN13/img/entete1.svg';
		this._elements = {};
	
		this.audiotag = null;

		template =  thisDoc.querySelector('template');
		shadow_element = this.attachShadow({mode: 'open'})//.appendChild(template.cloneNode(true));
		shadow_element.innerHTML = thisDoc.querySelector('template').innerHTML;
	}

	connectedCallback() {
		if (not_screen_context()) {
			return ;
		}

		let audiotag = this.querySelector('audio');
		this.audiotag = audiotag;
			// TODO prévoir quand audiotag est une référence, et non pas inclus dans le tag

		this.container = shadow_element.querySelector('.cpu-audio');
		// copying personalized data to audio tag
		for (var key of ['title', 'poster', 'canonical']) {
			this.audiotag.dataset[key] = this.dataset[key];
		}

		// WAS build_for_audiotag
		this.add_id_to_audiotag()
		this.dataset.ondeplayer = this.audiotag.id;

		this.build_controller();

		// see https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events for list of events
		[
			'ready', 'load', 'loadeddata', 'canplay', 'abort', 
			// 'error', 'stalled', 'suspend', 'emptied',
			'play', 'playing', 'pause', 'suspend', 'ended',
			'durationchange',  'loadedmetadata', 'progress', 'timeupdate', 'waiting'
		].forEach( function(on){ 
			audiotag.addEventListener(on, trigger.update); 
		});

		this.audiotag.addEventListener('loadedmetadata', CPU_Audio.recall_stored_play);
		// those ↓ for PHRACKING SAFARI
		this.audiotag.addEventListener('ready', CPU_Audio.recall_stored_play);
		this.audiotag.addEventListener('canplay', CPU_Audio.recall_stored_play);

		// ask ASAP metadata about media
		// we have to set in HTML code preload="none" due to a very laggy behaviour in HTTP2
		// https://stackoverflow.com/questions/14479413/chrome-ignoring-audio-preload-metadata
		if (this.audiotag.preload === '') {
			this.audiotag.preload = 'metadata';
		}
		this.audiotag.load();

		trigger.update({target : audiotag});
		CPU_Audio.recall_stored_play({target : audiotag});

		if (this.dontHideAudioTag === false) {
			this.audiotag.hidden = true;
			// PHRACK SAFARI
			this.audiotag.removeAttribute('controls');
			this.audiotag.setAttribute('data-ondeplayer', '');
		}	

		// TODO : Event should be set on controller , with checking event.originalTarget.classlist.has()
		querySelector_apply('.canonical', element_prevent_link_on_same_page);

	}

	disconnectedCallback() {
	}


	update_act_container(act) {
		this.classList.remove(
			'act-loading',
			'act-pause',
			'act-play');
		this.classList.add(`act-${act}`);
	}

	update_playbutton(event) {
		if (this.audiotag.readyState < self.audiotag.HAVE_CURRENT_DATA ) {
			self.update_act_container('loading');
			return;
		}

		this.update_act_container(this.audiotag.paused ? 'pause' : 'play');
	}

	update_line(type, seconds) {
		// type = 'elapsed', 'loading'
		let duration = this.audiotag.duration;
		this._elements[`${type}line`].style.width = duration === 0
												? 0
												: `${100*seconds / duration}%`;
	}

	update_time(event) {
		let timecode = convert.SecondsInTime(this.audiotag.currentTime);
		let link_to = absolutize_url(this.audiotag.dataset.canonical)+'#';
		link_to += this.audiotag.id ? (this.audiotag.id+'&') : '';
		link_to += 't='+timecode;

		let elapse_element = this._elements['elapse'];
		elapse_element.href = link_to;

		let total_duration = '…';
		if (!isNaN(Math.round(this.audiotag.duration))){
			total_duration = convert.SecondsInTime(Math.round(this.audiotag.duration));
		} 
		 
		elapse_element.innerHTML = `${timecode}
									<span class="${this.classname}-nosmall"> / ${total_duration}</span>`;
		this.update_line('elapsed', this.audiotag.currentTime);
	}

	update_loading() {
		this.update_line('loading', seconds);
		this.update_act_container('loading');
	}

	/// NNN?N???????
	update_id_container_infos(container_id) {
		let container = document.getElementById(container_id);
		let event = this;
		let audiotag = event.target;
		if (audiotag.error === 'error') {
			this.update_act_container('error');

		   switch (audiotag.error.code) {
				case audiotag.error.MEDIA_ERR_ABORTED:
					alert(__.s('media_err_aborted'));
					break;
				case audiotag.error.MEDIA_ERR_NETWORK:
					alert(__.s('media_err_network'));
					break;
				case audiotag.error.MEDIA_ERR_DECODE:
					alert(__.s('media_err_decode'));
					break;
				case audiotag.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
					alert(__.s('media_err_src_not_supported'));
					break;
				default:
					alert(__.s('media_err_unknow'));
					break;
		   	}
			return;
		}
		this.update_playbutton(container);
		this.update_time(container);
	}

	show_thobber_at(seeked_time) {
		if (this.audiotag.duration < 1) {
			// do not try to show if no metadata
			return;
		}
		var phylactere = this._elements['popup'];
		var elapse_element = this._elements['line'];

		phylactere.style.opacity = 1;
		phylactere.style.left = (100 * seeked_time / this.audiotag.duration ) +'%';
		phylactere.innerHTML = convert.SecondsInTime(seeked_time);
	}
	hide_throbber() {
		var phylactere = this._elements['popup'];
		phylactere.style.opacity = 0;
	}
	hide_throbber_later() {
		var phylactere = this._elements['popup'];
		if (phylactere._hider) {
			window.clearTimeout(phylactere._hider);
		}
		phylactere._hider = window.setTimeout(this.hide_throbber, 1000, container);

	}

	update_links() {
		var container = this;
		function ahref(category, href) {
			container._elements[category].href = href;
		}
		function remove_hash(canonical) {
			var hash_at = canonical.indexOf('#');
			return hash_at === -1 ? canonical : canonical.substr(0,hash_at);
		}

		var canonical = this.audiotag.dataset.canonical
		var url = (canonical === undefined ? '' : remove_hash(canonical) )
					+ `#${this.audiotag.id}` 
					+ ( this.audiotag.currentTime === 0 
							? ''
							: `&t=${convert.secondsInTime(this.audiotag.currentTime)}`
						);

		var _url = encodeURI(absolutize_url(url));
		var _title = encodeURI(this.audiotag.title);
		ahref('twitter', `https://twitter.com/share?text=${_title}&url=${_url}&via=${twitter_via}`);
		ahref('facebook', `https://www.facebook.com/sharer.php?t=${_title}&u=${_url}`);
		ahref('email', `mailto:?subject=${_title}&body=${_url}`);
		ahref('link', this.audiotag.currentSrc);
	}

	show_actions(event) {
		let container = (event !== undefined) ?
				CPU_Audio.find_interface(event.target) :
				this.container;
		container.classList.remove('show-main');
		container.classList.add('show-share');
		this.update_links(document.getElementById(container.dataset.ondeplayer), container)
	}
	show_main(event) {
		let container = (event !== undefined) ?
				CPU_Audio.find_interface(event.target) :
				this.container;
		container.classList.add('show-main');
		container.classList.remove('show-share');
	}
	element_attribute(element, key, missing) {
		return (element.attributes[key] === undefined) ? missing : element.attributes[key].value;
	}

	add_id_to_container() {
		this.id = this.id !== ''? this.id : (this.idPrefix + String(CPU_Audio.count_element++));
	}
	add_id_to_audiotag() {
		if (this.audiotag.id === '') {
			this.audiotag.id = CPU_Audio.dynamicallyAllocatedIdPrefix + String(CPU_Audio.count_element++);
		}
	}

	complete_template() {
		var canonical = this.audiotag.dataset.canonical;
		if (canonical === undefined) {
			canonical = document.location.href;
		}
		this._elements['canonical'].href = canonical;

		var title = this.audiotag.dataset.title;
		title = title === undefined ? cpu_i18n['untitled'] : title;
		this._elements['canonical'].innerText = title; 
		this._elements['canonical'].title = title;

		this._elements['poster'].src = this.audiotag.dataset.poster;
	}
	build_controller() {

		this.dataset.ondeplayer = this.audiotag.id;
		this.classList.add(this.classname);
		this.tabIndex = 0 // see http://snook.ca/archives/accessibility_and_usability/elements_focusable_with_tabindex and http://www.456bereastreet.com/archive/201302/making_elements_keyboard_focusable_and_clickable/

		// the following mess is to simplify sub element declaration and selection
		this._elements = {};
		let controller = this;
		querySelector_apply('*', function(element){
			element.classList.forEach(function(this_class) {
				if (controller._elements[this_class] === undefined) {
					controller._elements[this_class] = element;
				}
			});
		}, this.shadowRoot);

		this.complete_template();

		//this.add_related_controller(audiotag, container);
		let cliquables = {
			'pause'		: trigger.play,
			'play'		: trigger.pause,
			'time'		: trigger.throbble,
			'actions'	: this.show_actions,
			'back' 		: this.show_main,
			'poster'	: this.show_main,
		};
		for (let that in cliquables) {
			this._elements[that].addEventListener('click', cliquables[that]);
		}
		// key management
		this.addEventListener('keydown', trigger.key);
		// throbber management
		let timeline_element = this._elements['time'];
		let do_events = {
			'mouseover' : true,
			'mousemove' : true,
			'mouseout'  : false,

			'touchstart'  : true,
			// 'touchmove'   : true,
			'touchend'    : false,
			'touchcancel' : false,
		}
		for(let event_name in do_events) {
			timeline_element.addEventListener(
				event_name,
				do_events[event_name] ? trigger.hover : trigger.out);				
		}

		// throw simplified event
		this.show_main();
		trigger.update({target : this.audiotag});
	}

}

window.customElements.define('cpu-audio', CpuAudioElement);
window.customElements.define('cpu-controller', CpuControllerElement);
window.addEventListener('hashchange', trigger.hashOrder, false);
trigger.hashOrder({ at_start : true });



})();
</script>
